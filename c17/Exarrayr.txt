Шаблоны динамических массивов с автоматической проверкой индекса

                      (версия 1.2c)

                Руководство программиста

Содержание
==========

1. Введение

1.1. Совместимость
1.2. Технические параметры
1.3. Лицензионное соглашение
1.4. Обязательства автора
1.5. Компоненты, разработанные третьими сторонами
1.6. Техническая поддержка
1.7. Контактная информация
1.8. Благодарности

2. Состав дистрибутива

3. Правила применения

3.1. Применение динамических массивов
3.2. Применение динамических указателей
3.3. Применение регулируемых массивов
3.4. Применение ограниченных указателей
3.5. Поддержка библиотеки STL
3.6. Контроль индексов при отладке программы
3.7. Методы для ручной оптимизации программ

4. Рекомендации по применению

4.1. Возможные области применения
4.2. Производительность
4.3. Расход памяти
4.4. Взаимодействие с операционной системой

5. Технические сведения

5.1. Сведения о реализации
5.2. Особенности реализации штатных операций
5.3. Возможности по обработке исключений
5.4. Опции препроцессора

6. Вспомогательные возможности

6.1. Служебные константы
6.2. Служебные функции
6.3. Вспомогательные шаблоны
6.4. Вспомогательные структуры
6.5. Вспомогательные заголовочные файлы

Приложение 1: Сводная таблица определений и методов

Приложение 2: Известные ошибки

Приложение 3: Что нового


1. Введение
===========

Шаблон динамических массивов предназначен для создания
многомерных массивов неограниченного размера, к элементам
которых можно обращаться с использованием штатных операций
и функций языка C++. При этом обеспечивается автоматическое
распределение оперативной памяти и защита от ошибок
индексации без заметного снижения производительности.
для чего используется техника хранения каждого младшего
одномерного среза массива в непрерывной области памяти.

Наряду с динамическими массивами, в шаблоне реализованы
динамические указатели на элементы динамических массивов,
а также массивы с регулируемым размером и контролем
индексов и ограниченные указатели на элементы обычных,
регулируемых и динамических массивов.

На основе ограниченных указателей реализованы отладочные
указатели, предназначенные для организации контроля индексов
на этапе отладки программы. При сборке готовой программы
отладочные указатели заменяются обычными указателями и
контроль индексов отключается. Отладочные указатели могут
применяться в программах, написанных на языках C и C++.


1.1. Совместимость
------------------

Шаблон создается в соответствии со стандартами
C++: ISO/IEC 14882:1998(E) и C: ISO/IEC 9899:1990.

Для тестирования применяются трансляторы:
- Microsoft Visual C++ 6.0, 7.0, SDK 2003 R2, 2005, 2008, 2010.
- Borland C++ 3.1 (16-разрядный режим)
- Borland C++ 4.5 (32-разрядный режим)
- Borland C++ Builder 1.0.
- GNU g++ 2.9.6 (32-разрядный режим, Red Hat Linux 7.1).
- GNU g++ 3.3.3 (ARM, Pocket GCC, Windows Mobile 5).
- GNU g++ 4.1.2 (64-разрядный режим, SuSE Linux 10).
- GNU g++ 4.2.3 (Workbench).

Предыдущие версии шаблона тестировались в трансляторах:
- Microsoft Visual C++ 5.0,
- Microsoft.NET Framework SDK 1.0, 1.1.
- cxx (Digital Unix 4.0, DEC Alpha).


1.2. Технические параметры
--------------------------

- Размер дескриптора массива (*):                  2 слова
- Размер динамического указателя:                  2 слова
- Размер ограниченного указателя:                  4 слова

- Начальный размер памяти, выделяемой для
  массива, в байтах:                                     0

- Начальный фактический размер массива по
  каждому его измерению, в элементах:                    0

- Инициализация памяти:                       побайтовый 0
- Инициализация элементов массива
  конструктором по умолчанию:          от младшего индекса
- Разрушение элементов массива
  деструктором по умолчанию:           от старшего индекса

- Выравнивание первого элемента в каждом
  младшем одномерном срезе массива:
                для транслятора Visual C++ 7.0:    16 байт
                для прочих трансляторов:           1 слово

- Минимальное число инициализированных элементов,
  автоматически резервируемых вслед за последним
  заполненным элементом (**) в каждом младшем
  одномерном срезе массива:                              1

- Минимальный размер памяти, выделяемой
  для каждого заполненного младшего
  одномерного среза массива,    16 разр.:               44
  в байтах (***):               32 разр.:              104
                                64 разр.:              224

- Максимальный размер каждого младшего
  одномерного среза массива,    16 разр.:           34,988
  в байтах (***):               32 разр.:    1,607,077,576

- Максимальное число операций распределения
  памяти для одномерного среза массива
  в зависимости от размера заполненной
  части среза (****) в байтах:  16 разр.:2*log3 ((n+4)/ 96)
                                32 разр.:2*log3 ((n+8)/224)
                                64 разр.:2*log3((n+16)/480)

- Размер автоматически резервируемой памяти
  по отношению к размеру заполненной части
  массива (*****)                         в среднем: 37.5%
                                          максимум:   100%

- Минимальный фактический размер по каждому
  старшему измерению многомерного массива
  после его первого заполнения, 16 разр.:               10
  в элементах:                  32 разр.:               12
                                64 разр.:               13

- Максимальный фактический размер по каждому
  старшему измерению многомерного массива,
  в элементах:                  16 разр.:            8,746
                                32 разр.:      200,884,696

(*)     При заполнении многомерного массива автоматически
        создаются промежуточные дескрипторы для каждого
        одномерного среза по младшему измерению, далее для
        каждого двумерного среза по двум младшим измерениям
        и т.д. вплоть до старшего измерения. Динамическая
        память, отведенная под промежуточные дескрипторы,
        автоматически освобождается при удалении массива.

(**)    Под заполненным понимается элемент, для которого
        проведена какая-либо операция с контролем индексов
        (например, чтение или запись), либо выполнено явное
        распределение памяти.

(***)   Включает в себя автоматически зарезервированные элементы.

(****)  Включает в себя один автоматически зарезервированный
        элемент.

(*****) Размер заполненной части массива получается путем
        суммирования размера по каждому младшему одномерному
        срезу, включая один автоматически зарезервированный
        элемент для каждого среза. Предполагается, что размер
        каждого младшего одномерного среза больше минимального.
        Накладные расходы на промежуточные дескрипторы
        многомерного массива здесь не учитываются, т.к. они
        не зависят от размера младших одномерных срезов.


1.3. Лицензионное соглашение
----------------------------

Все авторские права на данный программный код исчерпывающе
описываются нижеследующим копирайтом:

Copyright 1998-2010, Р.Н.Шакиров, ИМаш УрО PAH.

Код предоставляется на условиях лицензии "public domain",
т.е. допускается свободное применение, модификация и
распространение кода, в том числе и для коммерческих целей,
при условии размещения данного копирайта в доступной для
конечного пользователя документации, а также добавления
исчерпывающих сведений о всех внесенных изменениях.

Данное соглашение не ограничивает Ваши исключительные права
на разработки, выполненные с применением данного кода и
накладывает на Вас какие-либо иные обязательства, кроме
упоминания об авторстве данного кода.


1.4. Обязательства автора
-------------------------

Автор подтверждает, что он урегулировал все юридические вопросы,
связанные с использованием в разработанном им программном коде
интеллектуальной собственности третьих сторон.

Автор гарантирует, что разработанный им программный код не
содержит компоненты, назначение которых отлично от основной
цели, декларированной в данной документации.

ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ ПО ПРИНЦИПУ
"КАК ЕСТЬ" ("AS IS") БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ
ПОДРАЗУМЕВАЕМЫХ. ВЫ ИСПОЛЬЗУЕТЕ ЕГО НА СВОЙ СОБСТВЕННЫЙ СТРАХ
И РИСК. АВТОР НЕ БУДЕТ НЕСТИ ОТВЕТСТВЕННОСТЬ ЗА УТРАТУ ДАННЫХ,
УЩЕРБ, УБЫТКИ ИЛИ ЛЮБЫЕ ДРУГИЕ ВИДЫ ПОТЕРЬ ПРИ ЛЮБЫХ СПОСОБАХ
ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.


1.5. Компоненты, разработанные третьими сторонами
-------------------------------------------------

Таковых нет.


1.6. Техническая поддержка
--------------------------

Обеспечивается на сайте http://www.imach.uran.ru/exarray

Просьба отсылать автору свoи конструктивные предложения,
а также сообщения об ошибках и проблемах совместимости.


1.7. Контактная информация
--------------------------

Автор:  к.т.н. Рауль Нурович Шакиров
620219, Россия. г.Екатеринбург, ул.Комсомольская, 34,
Институт Машиноведения УрО РАН.

Тел.:   +7 (343) 375-35-80
Почта:  raul@imach.uran.ru


1.8. Благодарности
------------------

Выражаю благодарность д.т.н. проф. Виллену Чистову за пожелание
иметь массив без ограничения размеров и к.т.н. Владимиру Титову
за тестирование основных компонентов шаблона.


2. Состав дистрибутива
======================

Шаблон реализован в виде следующих файлов:
   Exarray.cpp  - функции распределения памяти
   Exarray.h    - шаблон динамических массивов
   Exarray.txt  - руководство по применению шаблона (англ.)
   Exarrayr.txt - руководство по применению шаблона (рус.)
   Exdebug.h    - макросы отладочных указателей
   Exstring.h   - переопределения функций string.h
   Exthread.h   - макро локальной памяти потока
   ENG\         - исходные коды с комментариями (англ.)
   RUS\         - исходные коды с комментариями (рус.)

Файл Exarrayr.txt описывает документированные функции шаблона,
которые будут сохранены в последующих версиях шаблона, если
только в соответствующем разделе не оговорено противное.

Для удобства изучения в файлы *.cpp и *.h встроены
комментарии. Если программисты будут
испытывать затруднения при ознакомлении с текстами,
то автор всегда будет рад им помочь.

ПРЕДУПРЕЖДЕНИЕ:
Все определения файлов *.cpp и *.h, не обеспечивающие
штатные операции языка C++ и не перечисленные в
файле Exarrayr.txt, считаются недокументированными.
Они могут быть исключены или модифицированы в
последующих реализациях без каких-либо уведомлений.

Подкаталог PAPERS содержит методические материалы и примеры
программ по шаблону динамических массивов на русском языке:
   10           - исходные данные для перемножения матриц 10*10
   10.bat       - тест перемножения матриц 10*10
   10.res       - эталон для сравнения с результатом перемножения
   10.wrk       - результат перемножения
   Exarray.cpp  - упрощенный вариант файла Exarray.cpp
   Exarray.h    - упрощенный вариант файла Exarray.h
   Matrix.txt   - инструкция по подготовке исходных данных
   Matrix1.cpp  - перемножение матриц с использованием
                  статических массивов
   Matrix2.cpp  - перемножение матриц с использованием
                  динамических массивов
   Matrix3.cpp  - перемножение матриц с использованием
                  динамических массивов и ручной оптимизации
   P99pz.txt    - статья
Более новые материалы (после 2000-го года) выкладываются
на сайте проекта.


3. Правила применения
=====================

Для применения шаблона динамических массивов следует:

1.  Разместить в рабочем каталоге файлы
        Exarray.cpp
        Exarray.h
        Exdebug.h   (опция - макросы для отладочных указателей)
        Exstring.h  (опция - шаблоны для функций string.h)
        Exthread.h  (опция - макро локальной памяти потока)

2.  Включить в проект файл
        Exarray.cpp

3.  Добавить в тексты программных модулей директивы
        #include "Exarray.h"
        #include "Exdebug.h"   (опция)
        #include "Exstring.h"  (опция)
        #include "Exthread.h"  (опция)


3.1. Применение динамических массивов
-------------------------------------

1.  Динамический массив создается инструкцией:
        exarray<тип> имя;
    или с указанием начального размера:
        exarray<тип> имя (размер);

    Максимальный размер массива не задается. Постулируется,
    что массив имеет неограниченное число элементов, которым
    первоначально присвоены нулевые значения, либо значения,
    заданные конструктором класса по умолчанию. Фактически,
    массив первоначально имеет нулевой или заданный начальный
    размер, но при обращении к любому элементу размер массива
    автоматически увеличивается. При переполнении разрядной
    сетки индекса или нехватке памяти программа завершит
    работу с выдачей диагностики.

    * Элементы динамического массива должны относиться к
      одному из встроенных типов, либо или иметь открытый
      конструктор по умолчанию.

    Для передачи динамического массива в функцию в ней
    объявляется параметр вида:
        exarray<тип>& имя;
    или (с блокировкой записи):
        const exarray<тип>& имя;

    Для передачи динамического массива в функцию с блокировкой
    записи и отключением контроля индексов в ней объявляется
    параметр вида:
        const тип* имя;

    Многомерный динамический массив создается из динамических
    массивов меньшей размерности с помощью оператора typedef,
    Например, объявление двумерной матрицы может выглядеть так:
        typedef exarray<тип> vector;
        exarray <vector> matrix;

2.  Шаблон реализует все штатные операции и основные функции
    языка C++, включая арифметику над указателями, поддержку
    строковых функций из string.h, а также методы библиотеки
    STL для ручного управления размером массива и вызова
    большинства стандартных алгоритмов. Поэтому динамические
    массивы применяются в основном по тем же правилам, что
    штатные массивы языка C++.

    В частности, для обращения к элементу динамического массива
    применяется нотация:
        имя [индекс]

    * Особенности применения описаны в разделе "Особенности
      реализации штатных операций".

    * Для лучшей совместимости с существующими компиляторами
      некоторые редко используемые функции шаблона по умолчанию
      отключены - см. раздел "Опции".

    * Для реализации функций копирования строки в динамический
      массив требуется файл Exstring.h.


3.2. Применение динамических указателей
---------------------------------------

1.  Динамический указатель создается инструкцией:
        expoint<тип> имя;

    Динамическому указателю можно присваивать динамические
    массивы и указатели. При обращении по динамическому
    указателю размер динамического массива автоматически
    увеличивается.

    * При изменении размера массива все динамические
      указатели остаются действительными.

    * Динамические указатели могут применяться для
      адресации одномерных динамических массивов и старших
      динамических измерения многомерных массивов.

2.  Шаблон реализует все штатные операции и основные функции
    языка C++, включая арифметику над указателями, поддержку
    строковых функций из string.h, а также методы библиотеки
    STL для ручного управления размером массива и вызова
    большинства стандартных алгоритмов. Поэтому динамические
    указатели применяются в основном по тем же правилам, что
    штатные указатели языка C++.

    В частности, для обращения к элементу массива применяется
    нотация:
        имя [индекс]

    * Особенности применения описаны в разделе "Особенности
      реализации штатных операций".

    * Для лучшей совместимости с существующими компиляторами
      некоторые редко используемые функции шаблона по умолчанию
      отключены - см. раздел "Опции".

    * Для реализации функций копирования строки в динамический
      массив требуется файл Exstring.h.


3.3. Применение регулируемых массивов
-------------------------------------

1.  Регулируемый массив создается с нулевым начальным размером:
        exvector<тип> имя;
    или с указанием начального размера:
        exvector<тип> имя (размер);

    Элементам массива первоначально присвоены нулевые значения,
    либо значения, заданные конструктором класса по умолчанию.
    Размер массива надо задавать вручную. При обращении к
    элементу за пределами массива программа завершит работу
    с выдачей диагностики.

    * Элементы регулируемого массива должны относиться к
      одному из встроенных типов, либо иметь открытый
      конструктор по умолчанию.

    Для передачи регулируемого массива в функцию в ней
    объявляется параметр вида:
        exvector<тип>& имя;
    или (с блокировкой записи):
        const exvector<тип> имя;

    Для передачи регулируемого массива в функцию с блокировкой
    записи и отключением контроля индексов в ней объявляется
    параметр вида:
        const тип* имя;

2.  Шаблон реализует все штатные операции и основные функции
    языка C++, включая арифметику над указателями и методы
    STL для ручного управления размером массива и вызова
    большинства стандартных алгоритмов. Поэтому регулируемые
    массивы применяются в основном по тем же правилам, что
    штатные массивы языка C++.

    В частности, для обращения к элементу регулируемого массива
    применяется нотация:
        имя [индекс]

    * Особенности применения описаны в разделе "Особенности
      реализации штатных операций".

    * Для лучшей совместимости с существующими компиляторами
      некоторые редко используемые функции шаблона по умолчанию


3.4. Применение ограниченных указателей
---------------------------------------

1.  Ограниченный указатель создается инструкцией:
        exptr<тип> имя;

    Ограниченному указателю можно присваивать динамические
    и ограниченные массивы и указатели, при этом в указателе
    сохраняется информация о текущем размере массива. В отличие
    от динамического указателя, ограниченный указатель не
    отслеживает дальнейшее изменение размеров массива.
    При обращении по ограниченному указателю проводится контроль
    индекса: если память под требуемый элемент не распределена,
    то программа завершит работу с выдачей диагностики.

    * Ограниченный указатель на динамический массив
      действителен до тех пор, пока размер массива не
      изменится.

    Для создания ограниченного указателя, ссылающегося
    на обычный массив, применяется конструктор:
        exptr<тип> имя (массив, размер);

3.  Шаблон реализует все штатные операции и основные функции
    языка C++, включая арифметику над указателями и методы
    STL для ручного управления размером массива и вызова
    большинства стандартных алгоритмов. Поэтому ограниченные
    указатели применяются в основном по тем же правилам, что
    штатные указатели языка C++.

    В частности, для обращения к элементу массива применяется
    нотация:
        имя [индекс]

    * Особенности применения описаны в разделе "Особенности
      реализации штатных операций".

    * Для лучшей совместимости с существующими компиляторами
      некоторые редко используемые функции шаблона по умолчанию
      отключены - см. раздел "Опции".


3.5. Поддержка библиотеки STL
-----------------------------

Все шаблоны реализуют ряд определений библиотеки STL,
а динамические и ограниченные указатели являются
полноценными итераторами с произвольным доступом.

Общие определения:
   value_type           Тип элемента массива.
   size_type            size_t
   difference_type      ptrdiff_t
   iterator             Итератор элементов массива.
   const_iterator       ...
   pointer              Указатель на элемент массива.
   const_pointer        ...
   reference            Ссылка на элемент массива.
   const_reference      ...

Определения шаблонов указателей:
   iterator_category    random_access_iterator_tag

Общие методы:
   m.begin   () Итератор (указатель) первого элемента.
   m.end     () Итератор (указатель) элемента,
                следующего за последним.
   m.at     (i) Элемент (с проверкой индекса).

Методы шаблонов динамических массивов и указателей:
   m.size    () Число элементов.
   m.capacity() Число элементов, для которых
                распределена память.
   m.max_size() Максимально возможное число элементов.
   m.empty   () Предикат size() == 0.
   m.resize (n) Установка точного числа элементов.

Методы шаблона динамических массивов:
   m.clear   () Очистка массива с полным освобождением
                динамической памяти.
   m.swap   (m) Перестановка массивов без копирования
                элементов.

Методы begin() и end() обеспечивают вызов алгоритмов
библиотеки STL, опирающихся исключительно на применение
итераторов. Примером может служить алгоритм for_each.

Алгоритмы, получающие ссылку на контейнер, скорее всего,
работать не будут, т.к. шаблоны пока реализуют не все
штатные методы стандартных контейнеров. Отметим, что
ссылка на контейнер может передаваться косвенно через
вызов функций-конструкторов типа back_inserter().

ПРИМЕЧАНИЯ:
1.  Итераторы begin() и end() действительны до тех
    пор, пока размер массива не изменится.
2.  Если в динамическом массиве нет ни одного
    элемента, то begin() == end() и обращаться к
    элементу по итератору begin() нельзя.
3.  Применительно к динамическому или ограниченному
    указателю итератор begin() выдает указатель
    текущего элемента, т.е. элемента, на который
    установлен указатель, а end() указывает на
    элемент, следующий за последним в массиве.
    Если указатель находится за пределами массива, то
    выдается begin() == end() и обращаться к элементу
    по итератору begin() нельзя.
4.  Обращаться к элементу по итератору end() нельзя.
5.  Итераторы begin() и end() выполняют проверку
    индекса при обращении к элементу массива, если
    программа компилируется в отладочном режиме.
    Чтобы отменить проверку индекса, следует
    определить макро NCHECKPTR или NDEBUG,


3.6. Контроль индексов при отладке программы
--------------------------------------------

Для организации контроля индексов при отладке
программы применяется особая разновидность
ограниченных указателей - отладочные указатели.

Отладочные указатели отличаются от ограниченных
указателей тем, что при компиляции с макро NCHECKPTR
они реализуются через обычные указатели, не
выполняющие проверку индекса.

В роли отладочных указателей могут применяться
итераторы STL или специальные макроопределения.


3.6.1. Итераторы STL
--------------------

Итераторы могут применяться на трансляторах,
поддерживающих библиотеку STL.

Отладочный указатель создается инструкцией:
   exptr<тип>::iterator имя;

Для создания отладочного указателя на динамический
или регулируемый массив, динамический или ограниченный
указатель применяется методы begin() и end().


3.6.2. Отладочные макросы и указатели
-------------------------------------

Отладочные макросы могут применяться на любых
трансляторах, независимо от наличия или отсутствия
поддержки STL.

EXDEBUG(a)      - Выражение а выполняется только в отладочном
                  режиме при отсутствии макро NDEBUG.

EXARR(T,m,n)    - Определение отладочного массива m из n
                  элементов типа T с добавлением страховочного
                  элемента. Отладочный массив аналогичен
                  обычному массиву Т m[n] за исключением того,
                  что в отладочном режиме для него проводится
                  контроль индексов.

EXPTR(T)        - Отладочный указатель на массив элементов
                  типа T. Отладочный указатель аналогичен
                  обычному указателю Т* за исключением того,
                  что в отладочном режиме для него проводится
                  контроль индексов.

EXPTRTO(T,m,n)  - Формирование отладочного указателя на
                  массив m из n элементов типа T, заданный
                  обычным или отладочным массивом или
                  указателем. Если массив задан отладочным
                  массивом или указателем, то проводится
                  контроль диапазона.

EXPTRTYPE(m)    - Преобразование динамического или
                  регулируемого массива, динамического
                  или ограниченного указателя в формат,
                  допускающий присваивание отладочному
                  указателю.

EXPTRBASE(p)    - Преобразование отладочного массива или
                  указателя р к обычному массиву или
                  указателю без контроля индексов.

EXPTRCHECK(p,n) - Преобразование отладочного массива или
                  указателя p к обычному массиву или
                  указателю с контролем возможности
                  индексации элементов 0..n-1.

EXPTRINDEX(p,i) - Преобразование отладочного массива или
                  указателя p к обычному массиву или
                  указателю с контролем возможности
                  индексации элементов 0..i.

EXPTRNEW(T,n)   - Динамическое распределение памяти с
                  обнулением (см. ALLOW_EXARRAY_NEW_DELETE),
                  вызовом конструкторов и выдачей
                  отладочного указателя.

EXPTRDELETE(p)  - Вызовом деструкторов и освобождение
                  памяти, распределенной для отладочного
                  указателя р.

EXPTRALLOC(T,n) - Динамическое распределение памяти с
                  обнулением и выдачей отладочного
                  указателя, без вызова конструкторов.

EXPTRFREE(p)    - Освобождение памяти, распределенной
                  для отладочного указателя р.
                  Деструкторы не вызываются.

EXPTRALIGNED_ALLOC(T,n,a) - Распределение с выравниванием
                            a=1,2,4,8,16.

EXPTRALIGNED_FREE(p)      - Освобождение выровненного блока.

Контроль индексов для отладочных массивов и указателей
проводится при отсутствии макро NCHECKPTR и NDEBUG,
иначе отладочные массивы и указатели реализуются, как обычное

Пример:             Отладка (нет NCHECKPTR)         NCHECKPTR
=================== ===========================     ===========
EXARR(int,m,10);    int m___ [11];                  int m [11];
                    exptr<int> p=exptr<int>(m___,10)
EXPTR(int) p;       exptr<int> p;                   int* p;
p = EXPTRTO(m,10);  p = exptr<int>(m,10);           p = m;
EXPTRTYPE(m);       m;                              m.base();
EXPTRBASE(p);       p.base();                       p;


3.7. Методы для ручной оптимизации программ
-------------------------------------------

В шаблоны встроен неявный метод оптимизации по скорости,
заключающийся в возможности присвоения динамического или
регулируемого массива или указателя обычному константному
указателю. Запись в массив по такому указателю блокируется,
а контроль индексов и автоматическое увеличение размера
динамического массива - отключается.

Другие способы оптимизации основаны на применении отладочных
указателей (см. раздел 3.4) и специализированных методов.


3.7.1. Обращение к массиву без проверки индекса
-----------------------------------------------

   m.item   (i) Элемент.
   m.base    () Указатель базового массива.

ПРИМЕЧАНИЯ:

1.  Преобразование в константный указатель на
    первый элемент базового массива может
    выполняться неявно, например, при передаче
    динамического массива в функцию с
    параметром const тип*.

2.  Указатель действителен до тех пор,
    пока размер массива не изменится.


3.7.2. Управление размером массива
----------------------------------

    confine (i) Установить размер массива по указанному
                старшему индексу и зарезервировать память
                для дальнейшего роста массива.

    adjust (i)  Изменить размер массива с тем, чтобы выделить
                память для элемента с указанным индексом или
                удалить элементы с вдвое большим индексом.

    expand  (i) Увеличить размер массива с тем, чтобы выделить
                память для элемента с указанным индексом.

    shrink  (i) Уменьшить размер массива с тем, чтобы удалить
                элементы с индексом вдвое больше указанного.

ПРИМЕЧАНИЯ:

1.  Метод confine (i) аналогичен resize (i + 1). Оба метода
    характеризуются относительно высокими накладными расходами
    т.к. при каждом вызове выполняется распределение памяти.

2.  Методы expand() и shrink() являются упрощенными вариантами
    универсального метода adjust(). Методы expand() и adjust()
    гарантируют наличие в массиве элемента с указанным индексом.
    Метод shrink() сохраняет элемент с указанным индексом, если
    память для него уже выделена, иначе этот элемент останется не
    размещенным. Все методы выполняют фактическое распределение
    памяти только в том случае, если оно требуется. Итоговое число
    элементов определяется объемом распределенной памяти и может
    быть больше запрошенного.


3.7.3. Отладочные методы управления размером массива
----------------------------------------------------

  checkadjust (i) Аналог adjust()
  checkexpand (i) Аналог expand()
  checkshrink (i) Аналог shrink()
  checkindex  (i) Проверка i < len

При наличии макро NCHECKPTR первые три метода идентичны
своим аналогам, а метод checkindex() не делает ничего.

При отсутствии макро NCHECKPTR все методы устанавливают
максимальный индекс массива путем вызова confine(),
Если при обращении к методу checkindex() новое число
элементов больше текущего, то вызывается функция,
присвоенная ::exalloc_status.range_handler.


4. Рекомендации по применению
=============================

Методика применения шаблона описана в подкаталоге
PAPERS, где находится концептуальный текст P99pz.txt
и примеры программ, а также упрощенные варианты
файлов Exarray.h и Exarray.cpp для первоначального
ознакомления.


4.1. Возможные области применения
---------------------------------

1.  Эффективная альтернатива традиционным массивам и
    указателям языка C++, обеспечивающая полностью
    автоматическое распределение оперативной памяти.
    Преимущество автоматического распределения памяти
    по сравнению с ручным заключается в упрощении
    программирования и сокращении числа ошибок, а
    также в предсказуемости накладных расходов:
    не более 50% по времени выполнения программы и
    не более 100% по объему оперативной памяти,
    запрашиваемой у операционной системы.
    При ручном распределении памяти накладные
    расходы зависят от квалификации программиста,
    а также наличия времени для подбора оптимального
    метода распределения памяти.

2.  Для динамических массивов и указателей типа char
    реализованы строковые функции языка C из string.h,
    с автоматическим распределением памяти. Поэтому
    динамические массивы и указатели типа char могут
    применяться вместо строковых классов C++, таких,
    как string.

3.  Существующий программный код может быть переведен
    на использование динамических массивов и указателей
    путем замены деклараций, без необходимости менять
    исполняемые инструкции. Это позволяет, в частности
    переводить существующие 16-разрядные программы
    в 32-разрядные с умеренным (не более чем 4-х
    кратным) ростом расхода оперативной памяти.

4.  Ограниченный указатели могут применяться для
    организации контроля индексов при отладке
    программного кода, использующего обычные
    массивы и указатели.

5.  Регулируемые массивы могут применяться, как
    средство распределения памяти, более надежное и
    эффективное, чем штатные операторы new и delete.
    Обеспечивается:
    - контроль переполнения разрядной сетки;
    - обнуление выделяемой памяти;
    - изменение размера массива без его копирования;
    - минимизация фрагментации динамической памяти;
    - учет особенностей кэша L1 процессора Pentium
      позволяет ускорить обращение к многомерным
      массивам (на некоторых алгоритмах - в 2 раза);
    - при создании массива нулевой длины динамическая
      память не выделяется;
    - предусмотрен вспомогательный шаблон, позволяющий
      выделять память для временных объектов путем
      выполнения нескольких операций присваивания
      (см. раздел "Вспомогательные шаблоны").

6.  Все шаблоны могут применяться на унаследованных
    трансляторах, не реализующих механизм исключений
    и библиотеку STL.

7.  В качестве дополнительной возможности, все
    шаблоны реализуют ряд контейнерных методов
    библиотеки STL, а динамические и ограниченные
    указатели являются полноценными итераторами с
    произвольным доступом.
    В отличие от штатных контейнеров и итераторов
    библиотеки STL, обеспечивается возможность
    автоматического распределения оперативной
    памяти и защита от ошибок индексации.


4.2. Производительность
-----------------------

Применение динамических массивов вместо обычных
не отражается на производительности большинства
прикладных программ - при условии учета
особенностей динамических массивов, которые
оговариваются далее в этом разделе.

Динамические указатели облегчают преобразование
существующего программного кода при переходе от
обычных массивов к динамическим. Применять
динамические указатели при разработке нового
программного кода не рекомендуется из-за их
относительно невысокой производительности на
некоторых трансляторах.

Ограниченные указатели предназначены, главным
образом, для организации отладочного контроля
индексов.

При оптимизации программ следует учитывать
следующие особенности шаблонов:

1.  В отличие от обычных массивов, обращение к
    элементу динамического массива по индексу
    выполняется быстрее, чем обращение по
    динамическому или ограниченному указателю.
    * Разница в производительности зависит от
      транслятора: для Borland C++ это 2-3 раза,
      а для Visual C++ разницы может и не быть
      благодаря эффекту оптимизации кода,

2.  При передаче динамического массива в функцию по
    ссылке обеспечивается более быстрое обращение к
    массиву, чем при передаче через динамический или
    ограниченный указатель.

3.  Арифметические операции над динамическими и
    ограниченными указателями проводятся без проверки
    индекса. Операции ++ и -- быстрее в префиксном
    варианте, т.к. при выполнении постфиксных операций
    создается временный объект. По той же причине
    операции += и -= быстрее, чем + и -.

4.  В отличие от обычных массивов, динамический массив
    при создании обнуляется. Поэтому создание локального
    динамического массива занимает примерно столько же
    времени, что и заполнение массива данными.

5.  В критических для производительности циклах
    программы следует избегать обращения к элементам
    многомерных динамических массивов сразу по
    нескольким индексам. Если это обращение все-таки
    имеет место, то вместо обращения с контролем
    индекса m[i] можно использовать обращение без
    контроля индекса: m.item(i).

    ЗАМЕЧАНИЕ:
      Накладные расходы собственно на контроль индекса
      несущественны, т.к. на суперскалярных процессорах
      контроль индекса выполняется за 1 такт параллельно
      с вычислением исполнительного адреса. Но это в
      теории, а на практике трансляторы C++ испытывают
      затруднения при проведении различных оптимизаций
      если в соответствующем участке программного кода
      предусмотрен контроль индексов.

      Отключение контроля индексов помогает транслятору
      правильно сориентироваться в ситуации, особенно
      в случае применения многомерных массивов.

      Для одномерных массивов трансляторы обычно строят
      весьма эффективный код, поэтому отключать контроль
      индексов в этом случае не обязательно - разница в
      производительности составит не более 10% на Pentium
      и не более 30% на Pentium II/III.

      В качестве справки ниже приведен код, построенный
      транслятором Visual C++ 6.0 для присваивания
      m [i] = i (i находится в регистре esi).
      Звездочкой * помечены команды проверки индекса.
      Этих команд много, но:
      - mov ecx выполняется параллельно с mov eax
      - cmp и ja выполняются параллельно с вычислением
        исполнительного адреса eax+esi*4,
      - push, lea и call выполняются только при
        переполнении массива.

      * mov      ecx, DWORD PTR [esp+64]
        mov      eax, DWORD PTR [esp+60]
      * cmp      ecx, esi
      * ja       SHORT $L10381
      * push     esi
      * lea      ecx, DWORD PTR [esp+64]
      * call     ?grow@?$exblock@H@@IBEPAHI@Z ; exblock<int>::grow
      * $L10381:
        mov      DWORD PTR [eax+esi*4], esi

6.  Для повышения производительности следует применять
    трансляторы, выполняющие оптимизацию кода под
    целевой процессор (это особенно актуально, если
    программа будет выполняться на микропроцессорах
    Celeron и Pentium II/III). Трансляцию следует
    проводить в режиме Release. Если потребуется
    поднять производительность в режиме Debug, то
    следует разрешить подстановку inline функций.

7.  Производительность программы зависит не только
    от характеристик машинного кода, но также и от
    тонких особенностей размещения данных в оперативной
    памяти, влияющих на работу кэша микропроцессора
    (см. руководства, предоставляемые разработчиками
    микропроцессоров, а также статью p99pz.txt).

    При формальной замене обычных массивов на
    динамические схема размещения данных меняется,
    что само по себе влияет на производительность
    программы: если исходная схема размещения данных
    была неудачной, то производительность может
    увеличиться, иначе - уменьшиться.

    Влияние схемы размещения данных особенно заметно
    в случае вычислительных программ, выполняющих
    обработку многомерных массивов, где возможно
    2-5-кратное изменение производительности.


4.3. Расход памяти
------------------

Рекомендуемый метод экономии памяти заключается в своевременном
удалении всех неиспользуемых динамических массивов, для чего их
следует размещать в стеке. Если какой-либо массив требуется
хранить постоянно, то соблюдайте следующие рекомендации:

1.  После заполнения массива данными установите размер массива
    в соответствии с его фактическим заполнением. При полностью
    автоматическом распределении памяти размер динамического
    массива будет несколько больше требуемого, при этом
    освобождение неиспользуемой памяти не проводится.

2.  Если программа рассчитана на длительную работу, например,
    в качестве службы операционной системы, то периодически
    устанавливайте размер ее рабочих динамических массивов в
    соответствии с требуемым на данный момент времени.

3.  Компиляция в режиме "auto inline" может существенно увеличить
    размер исполняемого кода. Чтобы этого не произошло, включайте
    обычную подстановку inline функций.

    ПРИМЕЧАНИЕ: Режим "auto inline" установлен по умолчанию для
    Release mode в Microsoft Visual C++ .NET и выше. Чтобы его
    отключить, можно поставить опцию "only inline" или добавить
    в исходный код директивы:

        #ifdef  _MSC_VER
        #pragma auto_inline (off)
        #endif/*_MSC_VER*/


4.4. Взаимодействие с операционной системой
-------------------------------------------

Применение динамических массивов позволяет автоматически
компенсировать ошибки переполнения буфера за счет увеличения
количества памяти, выделяемой программе. В зависимости от
характера ошибки, объем затребованной памяти может привести
к исчерпанию системных ресурсов и резкому замедлению работы
операционной системы. Поэтому в ответственных случаях следует
ограничивать максимальный объем оперативной памяти, выделяемой
программе.


5. Технические сведения
=======================

Данный раздел содержит технические сведения о текущей реализации
шаблона без предоставления гарантий относительно того, что все
сведения будут справедливы для последующих версий шаблона.


5.1. Сведения о реализации
--------------------------

Каждый младший одномерный срез динамического массива
занимает непрерывную область памяти, состоящую из
трех участков:

1.  Элементы массива. Для каждого элемента проводится
    обнуление занимаемого участка памяти, после чего
    вызывается конструктор. К элементам допускается
    обращение по чтению и записи.

2.  Обнуленный участок, достаточный для размещения
    нескольких элементов базового типа (см. ниже).
    Если обнуленный участок содержит допустимые
    значения базового типа, то его можно читать
    при обращении к массиву без контроля индекса.

3.  Зарезервированная память, размер которой
    определяется автоматически.

Наличие обнуленного участка существенно при обращении
к массиву без контроля индекса, т.к. позволяет сделать
предсказуемыми последствия распространенной ошибки -
- обращение по индексу, равному числу элементов.

Минимальное число элементов базового типа T в обнуленном
участке памяти задается в файле Exarray.h с помощью макро
EXARRAY_EXTRA_ITEMS. Макро может принимать значения от 0
и выше. Штатное значение - 1.

Для целей экономии памяти "пустой" динамический массив,
т.е. массив без элементов, может разделять обнуленный
участок памяти с другими "пустыми" массивами того же типа.
Указатель на этот участок выдается защищенным статическим
методом stub().


5.2. Особенности реализации штатных операций
--------------------------------------------

Особенности шаблона обусловлены ограничениями языка C++:

1.  Операция sizeof выдает размер дескриптора массива,
    а не размер массива в байтах, как это имеет место
    в случае обычных массивов.
    Текущее число элементов динамического массива выдается
    методом size(). Размер динамического массива в байтах
    равен произведению size() на размер элемента.

2.  Операция & выдает указатель дескриптора массива, а не
    указатель базового массива. Эта разница существенна
    при присваивании массива указателю void *, и при
    передаче массива в функции типа sort или memcpy.
    В этом случае для обычного массива m будет значить
    то же, что и &m, т.к. эти указатели, хоть и относятся
    к разным типам, но содержат один и то же адрес. Но для
    динамического массива адреса m и &m будут разными.
    Указатель на базовый массив в этом случае выдается
    методом base(),

3.  При создании динамического массива число элементов
    не указывается, при этом разрешается обращаться к
    любому элементу массива по индексу или через
    динамический указатель.

    Распределение памяти выполняется автоматически.
    Для регистрации или предотвращения автоматического
    распределения памяти можно определить соответствующую
    функцию и присвоить ее глобальной переменной
    exalloc_status.grow_handler.

    Максимальный размер динамического массива в байтах
    содержится в константе EXCALCBLOCKSIZE_MAX,
    которая в 16-разрядной реализации содержит значение
    порядка UINT_MAX (64К), а в 32 и более разрядной -
    значение порядка INT_MAX.

    Максимальное число элементов, которое допускается
    шаблоном exarray, выдается методом max_size();
    операционная система и аппаратура могут накладывать
    дополнительные ограничения. Если выделить требуемую
    память не удается, то вызывается функция, присвоенная
    по set_exalloc_handler(). Если по set_exalloc_handler()
    присвоено значение NULL, то для обработки ошибки будет
    вызвана функция, присвоенной exalloc_status.size_handler,
    Обработчик по умолчанию вызывает abort().

    ЗАМЕЧАНИЕ:
      Применение set_exalloc_handler() вместо штатного
      для C++ обработчика set_new_handler() обусловлено
      различиями в компиляторах, выпущенных до утверждения
      стандарта C++ в 1998 году.

4.  Обращение к динамическому массиву по отрицательному
    индексу приводит к обработке ошибки распределения памяти
    (за исключением массива exarray<char>, если 16-разрядный
    индекс меньше -10). В случае обычных массивов эта ошибка
    может остаться незамеченной.

5.  Не следует индексировать динамический массив значениями
    типов char и выполнять арифметические операции над
    динамическими массивами и указателями с аргументами типов
    char. Используйте явное приведение к int.

    Реакция транслятора на эти нарушения заключается в выдаче
    сообщения о недоступности метода.

6.  Как и обычный массив, динамический массив нельзя
    копировать путем инициализации или присваивания,
    а также передавать в функцию по значению и возвращать
    в качестве ее результата. В этом случае выдается сообщение
    о недоступности конструктора копирования или оператора
    присваивания.

    Для передачи динамического массива в функцию следует
    объявить в функции ссылку на динамический массив,
    динамический или ограниченный указатель, либо обычный
    константный указатель на элемент базового массива.
    При передаче через ограниченный или константный
    указатель отключается возможность автоматического
    увеличения размера (при передаче через обычный
    указатель отключается также и контроль индексов);
    требуется также обеспечить неизменность размера
    динамического массива на время выполнения функции.

7.  Динамическому указателю можно присваивать динамические
    массивы и указатели, но нельзя присваивать обычные
    массивы и указатели, а также ограниченные указатели.

    Ограниченному указателю можно присваивать динамические
    массивы и указатели, регулируемые массивы и ограниченные
    указатели. Кроме того, при декларации ограниченного
    указателя ему можно сопоставить обычный массив,
    для чего следует передать в конструктор указатель
    первого элемента массива и число элементов.

8.  При обращении как к обычному, так и к динамическому
    массиву через ограниченный указатель доступны только
    ранее размещенные элементы. При попытке обращения
    к неразмещенному элементу вызывается abort() или
    иная функция, присвоенная exalloc_status.range_handler.
    Ограниченный указатель на динамический массив актуален
    до тех пор, пока число элементов в массиве не изменится.

9.  Обращение по динамическому или ограниченному
    NULL-указателю приводит к вызову abort() или иной
    функции, присвоенной exalloc_status.null_handler.
    В случае обычных указателей эта ошибка может
    остаться незамеченной.

10. В отличие от обычного указателя, динамическому или
    ограниченному указателю можно без явного преобразования
    типа присвоить ненулевое числовое значение.
    Логическая проверка такого указателя выдает истину,
    но при попытке обращения по нему возникает та же
    ошибка, что и при обращении по NULL-указателю.

11. В отличие от обычных указателей, при декларации
    динамического или ограниченного указателя
    допускается его инициализация константным
    динамическим массивом или указателем без явного
    преобразования типа.

    При попытке присваивания динамическому указателю
    константного динамического массива или указателя
    трансляторы Borland выдают сообщение о наличии
    двух дублирующих методов, а остальные трансляторы
    такое присваивание допускают.

    При попытке изменения размера константного
    массива (кроме expand) выдается сообщение об
    отсутствии требуемого метода.
    В остальных случаях выдается сообщение о
    невозможности модификации константного объекта.

12. В отличие от обычных указателей, для динамических
    и ограниченных указателей не реализованы операции
    приведения типа, как явного, так и неявного
    (например, к указателю на элемент базового класса).
    Исключением является приведение к обычному
    константному указателю на элемент, которое может
    выполняться по явному указанию или неявно - при
    инициализации, присваивании, вызове функции и
    возврате функцией значения. Обычный указатель на
    элемент динамического массива актуален до тех пор,
    пока массив существует и число элементов в нем не
    изменится.

    ЗАМЕЧАНИЕ 1:
      Приведение к обычному константному указателю можно
      использовать для многоступенчатых приведений.
      Например, чтобы привести указатель expoint<int> p
      к обычному указателю на char, следует использовать
      приведение (char *)(const int *)p.
      Полученный таким образом указатель является
      временным и поэтому его нельзя модифицировать.

    ЗАМЕЧАНИЕ 2:
      Для динамических и ограниченных указателей
      неявные приведения пока не обеспечиваются:
      для этого требуются конструктивы C++,
      которые предусмотрены в стандарте языка,
      но пока не реализованы ни в одном из
      доступных трансляторов.
      Возможность неявного приведения указателя на
      производный класс к указателю на базовый класс
      является потенциально опасной, т.к. позволяет
      нарушать принцип однородности массивов и даже
      разрушать находящиеся там данные с помощью
      совершенно "невинных", на первый взгляд,
      инструкций:
        class Shape {...};
        class Circle: public Shape {...};
        Circle c [10];
        Shape* ps = c;
        Shape  s;
        ps [2] = s;     // копия s угодила куда-то
                        // между c[0] и c[2].

    ЗАМЕЧАНИЕ 3:
      Как и в случае обычных массивов, возврат указателя
      на локальный динамический массив приводит к ошибке:
        const char* func() { exarray<char> a; return a; }


5.3. Возможности по обработке исключений
----------------------------------------

В шаблоне не предусмотрена обработка или запуск исключений,
т.к. он рассчитан на применение с различными компиляторами,
в том числе и с такими, которые не реализуют механизм
исключений. Тем не менее, шаблон позволяет задействовать
механизм исключений и реализовать их корректную обработку
в соответствии со стандартом C++ (ISO/IEC 14882).

1.  Локально определенные динамические массивы удаляются
    при вызове деструкторов в процессе очистки стека.

2.  Гарантируется отсутствие утечек памяти при запуске
    исключений в конструкторах элементов динамического
    массива.

3.  Если деструкторы элементов динамического массива
    могут запускать исключения, то для корректного
    освобождения памяти следует определить макро
    ALLOW_EXARRAY_EXCEPTIONS - в этом случае все
    исключения деструкторов будут перехватываться и
    обрабатываться в деструкторе динамического массива.

    ЗАМЕЧАНИЕ:
      Стандарт C++ рекомендует организовать перехват
      исключений в деструкторах, т.к. деструктор сам
      является частью механизма обработки исключений.
      В некоторых трансляторах, включая Visual C++ 6.0,
      выполнение этой рекомендации является
      необходимостью из-за некорректной реализации
      uncaught_exception().


5.4. Опции
----------

Шаблон рассчитан на применение различных трансляторов,
в том числе и таких, которые не выполняют в полном объеме
требования стандарта C++ (ISO/IEC 14882). Поэтому некоторые
возможности шаблона могут быть отключены. Чтобы их включить,
следует определить соответствующие макросы:
    #define опция

1.  Лингвистические опции по умолчанию выключены, т.к. они
    могут создать проблемы для трансляторов, не соответствующих
    стандарту C++.

    ALLOW_EXARRAY_ADDSUB        - разрешает операции + и -
            над динамическим массивом и целочисленным индексом,
            в результате чего строится динамический указатель.
            (иначе + и - определены только для указателей).
            * Приводит к разбуханию отладочной информации
              в Borland C++ 3.1.

    ALLOW_EXARRAY_SELECTION     - разрешает оператор ->.
    ALLOW_EXARRAY_ITERATORS     - разрешает оператор ->,
            а также методы для применения шаблонов в качестве
            итераторов и контейнеров библиотеки STL.
            * Не поддерживается в Borland C++ 3.1 и 4.5.
            * Реализована часть контейнерных методов STL.

    ALLOW_EXARRAY_EXCEPTIONS    - разрешает явное применение
            средств обработки исключений (требуется, если
            возможен запуск исключений в деструкторах
            элементов массива).
            * Не поддерживается в Borland C++ 3.1.
            * В Visual C++ обработка исключений в деструкторах
              локальных объектов и встроенных массивов
              реализована некорректно (но динамические
              массивы удаляются правильно).

2.  Опции совместимости. Включите эти опции, если Ваш транслятор
    сообщает о проблемах.

    ALLOW_EXARRAY_NEW_DELETE    - переопределить new[] и delete[]
            для макросов EXNEW и EXDELETE.
            * Всегда включена, если транслятор полностью совместим
              со стандартом C++ (__cplusplus >= 199711L), также для
              Visual C++ 5.0 и выше и для Borland C++ 4.5 и выше.

    ALLOW_EXARRAY_PLACEMENT     - поддержка placement delete.
            * Всегда включена, если транслятор полностью совместим
              со стандартом C++ (__cplusplus >= 199711L), также для
              Visual C++ 6.0 и выше.

    ALLOW_EXARRAY_CHARTYPE      - тип char отличен
            от signed/unsigned char.
            * Всегда включена, если транслятор полностью совместим
              со стандартом C++ (__cplusplus >= 199711L), также для
              Visual C++ 6.0 и выше, Borland C++ 4.5 и выше.

    ALLOW_EXARRAY_SIZETYPE      - тип size_t больше всех
            стандартных целочисленных типов, включая long.
            * Всегда включена для компиляторов, определяющих
              SSIZE_MAX или _WIN64 и _I64_MAX больше ULONG_MAX,
              как Visual C++ в 64-битном режиме.

    ALLOW_EXARRAY_PTRDIFFTYPE   - тип ptrdiff_t больше всех
            стандартных целочисленных типов, включая long,
            но не больше size_t.
            * Всегда включена для компиляторов, определяющих
              SSIZE_MAX или _WIN64 и _I64_MAX больше ULONG_MAX,
              как Visual C++ в 64-битном режиме.

    DISALLOW_EXARRAY_LONGTYPE   - запретить доступ к элементам
            массива по индексам типа long и unsigned long.

    DISALLOW_EXARRAY_INTTYPE   - запретить доступ к элементам
            массива по индексам типа int и unsigned int.

    DISALLOW_EXARRAY_SHORTTYPE   - запретить доступ к элементам
            массива по индексам типа short и unsigned short.

    ALLOW_EXARRAY_USING         - использовать директивы using
            для членов родительского класса-шаблона.
            * Всегда включена, если транслятор полностью совместим
              со стандартом C++ (__cplusplus >= 199711L), также для
              Visual C++ 2005 и выше, GNU g++ 3.4 и выше.
            * Не поддерживается в Borland C++ 3.1 и 4.5.

3.  Опции оптимизации.

    ALLOW_EXARRAY_SCHEDULING    - оптимизация кода для
            суперскалярных микропроцессоров Pentium и
            Pentium MMX (не рекомендуется).
            * Контрпродуктивен для Borland C++ 3.1 и 4.5,
              в ряде случаев - для Borland C++ Builder.
            * Эффект для Visual C++ зависит от приложения,
              под Visual C++ 6.0 данная оптимизация может
              привести к ошибке распределения памяти.

    NCHECKPTR                   - отключить отладочные средства.
            * Включен при компиляции в режимах NDEBUG и С.
            * Visual C++ ставит NDEBUG в режиме Release.


6. Вспомогательные возможности
==============================


6.1. Служебные константы
------------------------

    EXSIZE_T_MAX        - максимальное значение,
            выдаваемое в качестве результата
            целочисленных вычислений с контролем
            переполнения разрядной сетки.

    EXARRAY_ALIGN       - выравнивание блока памяти,
            распределяемого для динамического массива.
            Допустимые значения - 1, 2, 4, 8, 16.

    EXCALCBLOCKSIZE_SYS - размер системного
            заголовка блока памяти, зависящий
            от применяемого компилятора (если
            размер неизвестен, то можно указать
            верхнюю оценку, но не более 16).

    EXCALCBLOCKSIZE_MOD - начальный размер
            блока памяти с учетом системного
            заголовка при расчете по алгоритму
            функции excalcblocksize(), кратный
            pow(64,n)+/-16 байт.

    EXCALCBLOCKSIZE1..5 - начальный размер
            блока памяти без учета системного
            заголовка, рассчитанный по алгоритму
            функции excalcblocksize() и несколько
            последующих размеров, выдаваемых
            той же функцией.

    EXCALCBLOCKSIZE_MAX - максимальный размер
            блока памяти без учета системного
            заголовка, который допускается
            функциями распределения памяти
            (операционная система и аппаратура
            могут накладывать дополнительные
            ограничения).


6.2. Служебные функции
----------------------

Inline - функции целочисленных вычислений без знака и
с контролем переполнения разрядной сетки:

    exmuladd (s,n,k)   = s * n + k
    exmul    (s,n)     = s * n
    exadd    (n,k)     = n + k
    exchkadd (n,k,max) = n + k, если <= max, иначе ошибка.

ПРИМЕЧАНИЯ:
1.  Для генерации оптимального кода следует использовать C++
    и подставить константы на место s и k.
2.  При переполнении выдается EXSIZE_T_MAX (кроме exchkadd(),
    которая вызывает exalloc_status.size_handler).

Функции распределения памяти:

    size_t excalcblocksize (size_t blocksize);
        Расчет оптимального размера блока памяти
        в байтах, который должен быть не меньше
        требуемого. Если запрошенный размер
        слишком велик, то выдается EXSIZE_T_MAX.

    void* exmalloc  (size_t blocksize);
    void* exaligned_malloc
                    (size_t blocksize, size_t blockalign);
        Выделение блока памяти, заполненного нулями.

    void exmrealloc (void** p, size_t blocksize,
                     size_t memset_start,
                     size_t memset_stop);
    void exaligned_mrealloc
                    (void** p, size_t blocksize,
                     size_t blockalign,
                     size_t memset_start,
                     size_t memset_stop);
        Выделение, удлинение, укорочение или освобождение
        блока памяти p, а также обнуление заданного участка
        [memset_start,memset_stop).

    void exfree (void* p);
    void exaligned_free (void* p);
        Освобождение блока памяти p.

    Размер блока памяти задается в байтах. При переполнении
    разрядной сетки или нехватке памяти вызывается функция,
    присвоенная пo set_exalloc_handler().

    Функции exaligned_ предназначены для работы с блоками
    памяти, выровненными на 1, 2, 4, 8 или 16 байт.


6.3. Вспомогательные шаблоны
----------------------------

1.  Базовый шаблон динамического массива с переменным
    размером
        exblock<T>

    Шаблон exblock<T> реализует все методы шаблона
    exarray<T>, кроме перегрузки штатных операторов
    C++ и предназначен для порождения производных
    классов и шаблонов. Возможность непосредственного
    создания объектов exblock<T> не предусмотрена.

    Конструктор и деструктор exblock<T> объявлены
    защищенными и не содержат каких-либо операций,
    т.к. предполагается, что все операции по
    конструированию объектов будут выполняться
    в производных классах.

    В конструкторе производного класса следует задать
    e = stub() и len = 0. После этого, при необходимости,
    можно распределить память с помощью подходящего
    метода базового класса. В деструкторе производного
    класса следует вызвать метод clear().

    ПРИМЕЧАНИЕ 1:
      stub() - это защищенный статический метод, который
      выдает указатель на статический обнуленный массив
      размером sizeof(T) байт.

    ПРИМЕЧАНИЕ 2:
      Если элементы массива не нуждаются в конструировании,
      то память под динамический массив можно распределить
      функциями excalcblocksize(), exaligned_malloc() и
      exaligned_free() с выравниванием EXARRAY_ALIGN.
      Применять для этой цели new и delete нельзя.

2.  Шаблон массива с переменным размером
        explace<T>

    Наследует exblock<T> и дополнительно может
    присваиваться указателю expoint<T>.

3.  Шаблон стека массивов с переменными размерами
        exblockstack<T>

    Шаблон описывает стек массивов exblock<T>,
    откуда можно взять (get) массив и куда можно
    вернуть (put) массив, если он больше не нужен.
    Шаблон ориентирован на применение в
    конструкторах и деструкторах классов,
    производных от exblock<T>.

    Стек создается инструкцией:
        exblockstack<T> имя;

    Для создания массива в конструкторе производного
    класса вызывается метод
        имя.get(*this);
    Метод get извлекает массив из стека, а если стек
    пуст - то создает пустой массив exblock<T>.

    Для возвращения массива в стек в деструкторе
    производного класса вызывается метод
        имя.put(*this);

4.  Шаблон для вызова конструкторов и деструкторов
        exreloc_c<T>


6.4. Вспомогательные структуры
------------------------------

Вспомогательные структуры предназначены для применения в тех
областях, где использование наших шаблонов невозможно. Например,
структуры могут применяться для создания объектов в локальной
памяти потока (thread local storage), где могут применяться
только агрегированные типы без конструкторов.

1.  Структура динамического массива
        exblock_t

    Объекты структуры exblock_t идентичны по бинарному представлению
    объектам типов exblock, explace, exvector, exarray и expoint,
    поэтому они могут быть преобразованы в эти объекты с помощью
    static cast. Пример есть в реализации шаблона exblockstack.

    Объекты структуры exblock_t правильно инициализируются нулевыми
    значениями, если они создаются в глобальной, статической
    или любой другой инициализируемой нулями памяти.

2.  Структура стека динамических массивов
        exblockstack_t

    Объекты структуры exblockstack_t идентичны по бинарному
    представлению объектам типов exblockstack, поэтому они могут
    быть преобразованы друг в друга с помощью static cast.

    Объекты структуры exblockstack_t правильно инициализируются
    нулевыми значениями, если они создаются в глобальной,
    статической или любой другой инициализируемой нулями памяти.


6.5. Вспомогательные заголовочные файлы
---------------------------------------

1.  Файл Exthread.h для поддержки локальной памяти потока
    (thread local storage) определяет значение макро
    EXTHREAD_LOCAL.

    Этот файл не используется нашими шаблонами, но предназначен
    для создания программ, использующих локальную память потока.
    Файл содержит определения для Borland C++, Microsoft
    Visual C++ and GNU gcc.

    Заголовочный файл определяет макро EXTREAD_LOCAL пустым
    для однопоточных приложений и в зависимости от компилятора
    для многопоточных приложений. Значение определяется только
    если оно не было определено внешним образом.

    Кроме того, файл содержит закомментированные неполные
    определения для некоторых других компиляторов.


Приложение 1: Сводная таблица определений и методов
===================================================

В файле Exarray.h описаны следующие основные шаблоны:
    exblock<T>      Шаблон блока памяти с переменным размером.
                    доступного через ограниченный указатель.
    explace<T>      Шаблон блока памяти с переменным размером,
                    доступного через динамический и ограниченный
                    указатели.
    exarray<T>      Шаблон динамического массива.
    expoint<T>      Шаблон динамического указателя,
    exvector<T>     Шаблон регулируемого массива.
    exptr<T>        Шаблон ограниченного указателя.
    exblockstack<T> Шаблон стека блоков памяти с переменным
                    размером.
Шаблоны exblock, explace, и exblockstack предназначены для целей
реализации производных классов. Возможность непосредственного
создания объектов exblock и explace не предусмотрена.

Взаимосвязь классов:

         ссылка          агрегация
exptr     --->   exblock    <---   exblockstack
                 |
                 +- exvector
                 |
expoint   --->   +- explace
                    |
                    +- exarray
                 наследование

-----------------------------------------------------------
                            exblock exvector        exptr
                            explace exarray expoint
-----------------------------------------------------------
   = (int)                                     +
   = (const*)                                          +
   = (exblock&)                                        +
   = (exvector&)                                       +
   = (explace&)                                +       +
   = (exarray&)                                +       +
   = (expoint)                                 +       +
   = (exptr)                                           +
   [], *                               +       +       +
   ->                                  #       #       #
   += -=                               #       +       +
   +  -  ++  --                                +       +
   == != < > <= >= -                   +       +       +
   const T*                            +       +       +
-----------------------------------------------------------
   m.size    ()                +       +       +
   m.capacity()                +       +       +
   m.max_size()                +       +       +
   m.empty   ()                +       +       +
   m.resize (n)                +       +       +
-----------------------------------------------------------
   m.confine(i)                +       +       +
   m.adjust (i)                +       +       +
   m.expand (i)                +       +       +
   m.shrink (i)                +       +       +
   m.checkadjust (i)           +       +
   m.checkexpand (i)           +       +
   m.checkshrink (i)           +       +
   m.checkindex  (i)           +       +
-----------------------------------------------------------
   m.item   (i)                +       +       +       +
   m.base    ()                +       +       +       +
   m.at     (i)                +       +       +       +
   m.access (i)                +       +       +       +
-----------------------------------------------------------
   value_type                  #       #       #       #
   size_type                   #       #       #       #
   difference_type             #       #       #       #
   iterator                    #       #       #       #
   const_iterator              #       #       #       #
   pointer                     #       #       #       #
   const_pointer               #       #       #       #
   reference                   #       #       #       #
   const_reference             #       #       #       #
   iterator_category                           #       #
-----------------------------------------------------------
   m.begin   ()                #       #       #       #
   m.end     ()                #       #       #       #
   m.clear   ()                +       +
   m.swap   (m)                +       +
-----------------------------------------------------------
                   exblockstack
-----------------------------------------------------------
   get       ()          +
   put      (m)          +
-----------------------------------------------------------

Легенда:
+   Реализовано
#   Реализовано, как дополнительная возможность
    (см. раздел "Опции").
n   Размер
i   Индекс
m   exblock, exvector, explace или exarray


Приложение 2: Известные ошибки
==============================

1.  Не используйте выражения вида m [i] = func (m [j]), где i > j,
    и func принимает ссылку на аргумент, запрашиваемую значком &
    в спецификации. Это может примесит к ошибке GPF, т.к. ссылка
    на m [i] перестает быть действительной после перемещения m
    для размещения элемента m [i]. Ошибка возникает в некоторых
    компиляторах, например, Visual C++ .NET.

    РЕКОМЕНДАЦИЯ: Используйте следующий код для предварительного
                  распределения памяти под m [i]:
                    m [i] = 0; m [i] = func (m [j]);
                  или
                    m.expand (i); m [i] = func (m [j]);

2. Если макро ALLOW_EXARRAY_SCHEDULING установлено под
   компилятором Microsoft Visual C++ 6.0, то выражения вида
   m [i] = m [j] могут привести к ошибке GPF, если i > j,
   m относится к шаблону exarray и автоматически перемещается
   для размещения элемента m [i]. В некоторых специальных
   случаях компилятор Visual C++ 6.0 запоминает в регистре
   ссылку на m [j], которая перестает быть действительной
   после перемещения m для размещения элемента m [i] и после
   этого применяет ссылку для обращения к m [j].

   РЕКОМЕНДАЦИЯ: Не включайте макро ALLOW_EXARRAY_SCHEDULING.

3. Компиляция в режиме "auto inline" может существенно увеличить
   размер исполняемого кода. Этот режим установлен по умолчанию
   для Release mode в Microsoft Visual C++ .NET и выше.

   РЕКОМЕНДАЦИЯ: Отключайте режим "auto inline" в настройках
                 компилятора, либо в исходном коде. Для Microsoft
                 Visual C++ это можно сделать с помощью директив:

                   #ifdef  _MSC_VER
                   #pragma auto_inline (off)
                   #endif/*_MSC_VER*/


Приложение 3: Что нового
========================

20.02.1999 - Шаблон размещен в Интернет.


18.07.1999

- Заблокировано покомпонентное присваивание динамических массивов.


20.09.1999

- Реализованы операции над константными динамическими указателями.

- Улучшена диагностика присваивания динамических массивов.

- Устранены утечки памяти при вызове метода reserve() для пустых
  массивов и при вызове метода resize(0).

- Реализованы оптимизированные методы управления размером.


25.11.1999

- Из шаблона exarray выделен базовый шаблон exblock
  с методами распределением памяти.

- Реализован шаблон exblockstack для целей оптимизации
  распределения памяти.

- Реализован шаблон ограниченных указателей exptr и
  средства контроля индексов на этапе отладки программы.

- Поддержка Visual C++ 5.0.


28.11.1999

- Модифицирована методика обработки ошибок.


28.12.1999

- Обеспечена совместимость с режимом __STDC__.


12.04.2000

- Поддержка Visual C++ 6.0.

- Максимальный размер 32-разрядного динамического
  массива уменьшен в два раза - с 4Г до 2Г.
  Это потребовалось для того, чтобы обойти ошибку
  в Visual C++ 6.0: если не установлен SP3, то в
  режиме оптимизации по скорости транслятор вычисляет
  константные выражения типа (SIZE_T_MAX-4)/4 по
  правилам знаковой арифметики.
  Изменения затронули функции exmuladd() и exmul()
  В 16-разрядном режиме максимальный размер массива
  по-прежнему 64К.

- Вместо константы SIZE_T_MAX теперь применяется
  константа EXSIZE_T_MAX, задающая максимальное
  значение результата целочисленных вычислений
  с контролем переполнения разрядной сетки.


17.05.2000

- Подготовлена документация в файле Exarray.txt.

- Проведена ревизия методов шаблона. Выделены
  стабильные (документированные) методы, которые
  в последующих модификациях шаблона не будут
  исключаться или переопределяться. Некоторые
  методы исключены или объявлены закрытыми.

- Устранена возможность утечек памяти при запуске
  исключений в конструкторах элементов массива.

- Устранены перекрестные ссылки, приводившие к
  разбуханию отладочной информации в трансляторе
  Borland C++ 3.1.

- Реализованы методы STL: begin(), end(),
  at(),swap(), clean(), функция memmove()
  и перегруженный оператор ->.

- Некоторые возможности шаблона теперь следует
  подключать явным образом.


23.05.2000

- Оптимизирован код, выполняющий обращение к элементу
  массива с проверкой индекса (5-10% на процессоре
  Pentium с транслятором Visual C++).


25.05.2000

- Совместимость с cxx на платформе Alpha (Digital Unix 4.0B).


08.02.2001

- Исправлена ошибка в операторах присваивания динамических
  массивов и указателей ограниченным указателям (не было
  обнуления k).


22.09.2002

- Совместимость с GNU g++ 2.9.6.


06.12.2002

- Изменены имена обработчиков ошибок, некоторые функции
  вынесены в файлы Exdebug.h и Exstring.h.

- Новый шаблон exvector с контролем индексов, но без
  автоматического увеличения размера массива.

- Добавлены функции распределения памяти с выравниванием
  (реализованы пока только для Visual C++ 7.0, иначе они
  сводятся в вызову обычных функций).

- Совместимость с Visual C++ 7.0.


29.01.2003 - Версия 1.0 beta public

- Добавлена assert-диагностика при контроле индексов и указателей.

- Добавлены методы распределения памяти confine(), shrink() и
  checkshrink().

- Исправлена ошибка в определении метода chsize(), из-за которой
  он был аналогичен expand(). Метод переименован в adjust().

- Метод checksize() переименован в checkindex().

- Добавлено отладочное макро EXDEBUG в файл Exdebug.h.

- Уточнено лицензионное соглашение и дополнена документация.

- Теперь вся документация размещается в одном файле.


14.03.2003 - Обновление версии 1.0 beta public

- Подготовлен перевод документации на английский язык.


05.07.2003 - Версия 1.1 beta public

- Метод stub() перемещен в шаблон exblock для восстановления
  совместимости с Borland C++ 3.1.

- Шаблон exvec переименован в exvector.

- Комментарии к исходным кодам переведены на английский.


12.11.2005 - Версия 1.1a beta public

- Обновлена документация и комментарии в коде.

- ИСПРАВЛЕНО: Опция ALLOW_EXARRAY_SCHEDULING теперь по
              умолчанию отключена (см. Известные ошибки).


05.09.2006 - Версия 1.2 beta internal

- Новое макро EXPTRINDEX.

- Новая опция ALLOW_EXARRAY_SIZETYPE для совместимости с некоторыми
  64-разрядными компиляторами.

- ИСПРАВЛЕНО: Новая опция ALLOW_EXARRAY_USING для совместимости
              шаблонов со стандартом C++ ISO/IEC 14882.

- ИСПРАВЛЕНО: Макро EXPTRCHECK теперь возвращает константный
              указатель для константных объектов.

- ИСПРАВЛЕНО: Не удается присвоить NULL константному ограниченному
              или отладочному указателю без явного преобразования
              типа.


29.11.2006 - Версия 1.2 beta public

- ИСПРАВЛЕНО: Программа сваливается после компиляции в режиме Release под
              трансляторами Microsoft Visual C++ .NET, SDK 2003 и 2005
              с опцией /Ob2 (auto inline).


30.04.2007 - Версия 1.2a beta public

- Улучшена совместимость с GNU g++ 3.4 и выше (не надо явно указывать
  ALLOW_EXARRAY_USING)

- ИСПРАВЛЕНО: Заголовочный файл теперь не переопределяет NULL для
              трансляторов GNU g++.


12.06.2007 - Обновление документации к версии 1.2a beta public

- Расширенный список известных ошибок.


12.06.2009 - Обновление документации к версии 1.2a beta public

- Проверена совместимость с Visual C++ 2008.

- Поправлен раздел 5.2.


28.07.2009 - Версия 1.2b public

- Обеспечена совместимость с GNU g++ 4.1.2 в 64-разрядном режиме
  и c g++ 4.2.3,

- Разрешено применение индексов типов long и unsigned long.

- Новые опции DISALLOW_EXARRAY_LONGTYPE, DISALLOW_EXARRAY_INTTYPE
  и DISALLOW_EXARRAY_SHORTTYPE для запрещения индексов типов
  (unsigned) long, int и short.

- Новая опция ALLOW_EXARRAY_PTRDIFFTYPE для применения индексов
  ptrdiff_t, если они отличны от числовых типов long/int/short.

- ИСПРАВЛЕНО: Опция ALLOW_EXARRAY_SIZETYPE не устанавливается для
              64-разрядных компиляторов Microsoft Visual C++.

- ИСПРАВЛЕНО: Нельзя использовать индексы типа unsigned int для
              64-разрядных компиляторов GNU gcc.

- ИСПРАВЛЕНО: Не определяется совместимость компилятора C++
              со стандартами ISO/IEC 14882:1998 и 14882:2003.

- Бета-тестирование завершено.


28.07.2010 - Версия 1.2c public

- Файл Exthread.h определяет префикс локальной памяти потока
  EXTHREAD_LOCAL.

- Документирована структура exblock_t для размещения массива в
  локальной памяти потока.

- Структура exblockstack_t для размещения стека массивов в
  локальной памяти потока.

- Разделы 6.4 и 6.5 документации.


27.10.2010 - Обновление документации к версии 1.2c public

- Правки в документации и комментариях к Exarray.h.


20.11.2010 - Обновление документации к версии 1.2c public

- Исправлено описание макро EXARR.

- Исправленный комментарий в Exarray.h.


20.11.2010
