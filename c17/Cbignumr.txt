      Целые числа с неограниченной разрядной сеткой

             (класс cBigNumber, версия 2.1c)

                Руководство программиста

                                    Посвящается маме.

Содержание
==========

1. Введение

1.1. Совместимость
1.2. Технические параметры
1.3. Лицензионное соглашение
1.4. Обязательства автора
1.5. Компоненты, разработанные третьими сторонами
1.6. Техническая поддержка
1.7. Контактная информация
1.8. Благодарности

2. Состав дистрибутива

2.1. Тестовые программы

3. Правила применения

3.1. Объявление неограниченных чисел и штатные операции C++
3.2. Дополнительные операции, функции и методы
3.3. Функции и методы для ручной оптимизации программ
3.4. Определение простых чисел и факторизация

4. Рекомендации по применению

4.1. Возможные области применения
4.2. Производительность
4.3. Расход памяти
4.4. Взаимодействие с операционной системой
4.5. Предупреждение ошибок
4.6. Встроенные средства предупреждения ошибок

5. Технические сведения

5.1. Сведения о реализации
5.2. Особенности реализации штатных операций

Приложение 1: Пояснительная записка к работе на конкурс SofTool'99

Приложение 2: Известные ошибки

Приложение 3: Что нового


1. Введение
===========

Класс cBigNumber вводит целые числа неограниченной разрядности,
над которыми могут выполняться все штатные операции языка C++:
арифметические, логические, побитовые, сравнение, сдвиги, а также
потоковый ввод-вывод со всеми целочисленными модификаторами.
Дополнительные функции - возведение в степень, возведение в
степень по модулю и проверка на простоту по методу Миллера.

Класс оптимизирован для работы с числами размером до 100,000
и более двоичных разрядов. Испытания проводились для чисел,
содержащих до 12,000,000 двоичных разрядов.


1.1. Совместимость
------------------

Класс создается в соответствии со стандартами C++
ISO/IEC 14882:1998(E) и C++11 ISO/IEC 14882:2011.

Реализация класса не зависит от разрядности конкретного
вычислительного устройства, но предполагается, что числа
представляются в дополнительном двоичном коде. Класс
использует целочисленную машинную арифметику и не
задействует операции над числами с плавающей точкой.

Тестирование класса проводится в следующих трансляторах:
- Microsoft Visual C++ 6.0, 7.0, SDK 2003 R2, 2005-2010, 2015-2017.
- Borland C++ 3.1 (16-разрядный режим).
- Borland C++ 4.5 (32-разрядный режим).
- Borland C++ Builder 1.0.
- GNU g++ 2.9.6 (32-разрядный режим, Red Hat Linux 7.1).
- GNU g++ 3.3.3 (ARM, Pocket GCC, Windows Mobile 5, 6.1).
- GNU g++ 4.1.2 (32 и 64-разрядный режим, SuSE Linux 10).
- GNU g++ 4.2.3 (32-разрядный режим, Workbench).

Под Microsoft Visual C++ 2005 и выше класс использует встроенные
32/64 и 64/128-разрядные функции компилятора для аппаратного
умножения, сдвигов и т.п. Аналогичные возможности для более широкого
набора компиляторов, а также для 64/32 и 128/64-разрядного
аппаратного деления обеспечиваются в дополнительном ассемблерном
пакете (см. ниже).

Под Microsoft Visual C++ 2013 и выше класс использует встроенные
функции компилятора для вычитания с займом при делении на числа
малой разрядности (два машинных слова). Аналогичное ускорение
деления на числа большей разрядности обеспечивается в
дополнительном ассемблерном пакете (см. ниже).

Код с 32-разрядной ассемблерной оптимизацией доступен как
дополнительный пакет для следующих трансляторов:
- Microsoft Visual C++ 6.0, 7.0, 2003-2017 и выше.
- Borland C++ Builder 1.0 и выше.
- Borland C++ 4.5 (кроме умножения с накоплением).

Код с 64-разрядной ассемблерной оптимизацией доступен как
дополнительный пакет для Microsoft Visual C++ 2005-2017 и выше,
протестирован под:
- Microsoft Visual C++ 2010, SDK 7.1 x64
- Microsoft Visual C++ 2015

Код с 32/64/128-разрядным ассемблерным умножением и делением
доступен как дополнительный пакет для GNU g++, протестирован под:
- GNU g++ 4.1.2 (32 и 64-разрядный режим, SuSE Linux 10).

Класс поддерживает многопоточность, подробная информация
приведена в разделах 3 и 4.2.4.


1.2. Технические параметры
--------------------------

Технические параметры рассчитаны в предположении, что байт
содержит 8 бит, машинное слово содержит 16, 32 или 64 бита
типа size_t. Некоторые параметры зависят от размера CBNL
слова языка С, которое содержит 32-разрядное или 64-разрядное
целое стандартного типа long или зависимого от компилятора
типа, определенного в файле Cbnl.h.

- Размер дескриптора числа в машинных словах:            2

- Представление числа:  нормализованный дополнительный двоичный
                        код с переменным числом CBNL слов С
                        в порядке от младших слов к старшим

- Начальное значение числа по умолчанию:                 0

- Начальный размер динамической памяти, выделяемой
  для числа 0, в байтах:                                 0

- Размер служебной информации для представления
  числа, в CBNL словах:         число 0:           0 или 2
                                число не 0:              2

- Минимальный размер памяти, выделяемой для
  для не-0 числа, в CBNL словах (*):                     3

- Начальный размер динамической памяти, выделяемой
  для не-0 числа, в байтах (*): 16-разр.:               44
                                32-разр.:              104
                                64-разр.:              224

- Максимальный размер памяти, выделяемой
  для числа, в байтах (*):      16-разр.:           34,988
                                32-разр.:    1,607,077,576
                                64-разр.:        системный

- Максимальное число операций распределения
  памяти для числа в зависимости от размера
  кода числа n, в байтах (*):   16-разр.:2*log3 ((n+4)/ 96)
                                32-разр.:2*log3 ((n+8)/224)
                                64-разр.:2*log3((n+16)/480)

- Размер автоматически резервируемой памяти
  по отношению к фактическом размеру двоичного
  кода числа (**)                         в среднем: 37.5%
                                          максимум:   100%

- Максимальный расход памяти на оптимизацию
  операции умножения,           16-разр.:             1.5K
  в байтах (***,****)           32-разр. и более:      90K

- Расход памяти на оптимизацию операции
  деления по отношению к размеру
  делителя (***,*****):         32-разр. и менее:    3200%
                                64-разр.:            6400%

- Максимальный расход памяти на оптимизацию
  операции деления,             16-разр.:               2K
  в байтах (***,*****):         32-разр.:              64M
                                64-разр.:             128M

(*)     Включает в себя служебную информацию.

(**)    Предполагается, что размер числа больше минимального.

(***)   Кроме операций c таблицей сдвигов. Максимальный расход
        памяти зависит от настроек в файле Cbignumf.h.

(****)  Не включает в себя затраты на промежуточное копирование,
        равные размеру операндов.

(*****) Оптимизация проводится для делителей размером до 60 байт
        в 16-разрядном режиме, до 2M байт в 32-разрядном режиме
        и до 1M байт в 64-разрядном режиме.


1.3. Лицензионное соглашение
----------------------------

Все авторские права на данный программный код исчерпывающе
описываются нижеследующим копирайтом:

Copyright 1999-2017, Р.Н.Шакиров, ИМаш УрО PAH.

Функционально полная версия исходного кода, написанная
на С+ без явного использования машинных команд,
предоставляется на условиях лицензии "public domain",
т.е. допускается свободное применение, модификация и
распространение кода при при условии размещения данного
копирайта в доступной для конечного пользователя
документации, а также добавления исчерпывающих сведений
о всех внесенных в данный код изменениях.

Данное соглашение не ограничивает Ваши исключительные права
на разработки, выполненные с применением данного кода и
накладывает на Вас какие-либо иные обязательства, кроме
упоминания об авторстве данного кода.


1.4. Обязательства автора
-------------------------

Автор подтверждает, что он урегулировал все юридические вопросы,
связанные с использованием в разработанном им программном коде
интеллектуальной собственности третьих сторон.

Автор гарантирует, что разработанный им программный код не
содержит компоненты, назначение которых отлично от основной
цели, декларированной в данной документации.

ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ ПО ПРИНЦИПУ
"КАК ЕСТЬ" ("AS IS") БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ
ПОДРАЗУМЕВАЕМЫХ. ВЫ ИСПОЛЬЗУЕТЕ ЕГО НА СВОЙ СОБСТВЕННЫЙ СТРАХ
И РИСК. АВТОР НЕ БУДЕТ НЕСТИ ОТВЕТСТВЕННОСТЬ ЗА УТРАТУ ДАННЫХ,
УЩЕРБ, УБЫТКИ ИЛИ ЛЮБЫЕ ДРУГИЕ ВИДЫ ПОТЕРЬ ПРИ ЛЮБЫХ СПОСОБАХ
ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.


1.5. Компоненты, разработанные третьими сторонами
-------------------------------------------------

1. Strong Probable Primarily test for base b
   by Olivier Langlois <olanglois@sympatico.ca>
   Общедоступный код.

2. Tausworth based random number generator.
   Ref. Glenn Rhoads' home page at
   http://remus.rutgers.edu/~rhoads/Code/code.html
   Общедоступный код.

3. Microsoft(R) Visual C++ 6.0 Compiler (Enterprise Edition).
   Лицензирован для Института машиноведения УрО РАН.

4. MSDN Subscriptions library, April 2001
   Лицензирована для Института машиноведения УрО РАН.

5. Microsoft(R) Visual C++ 2010 Express Compiler.
   Общедоступное программное обеспечение.

6. Microsoft(R) Windows SDK v7.1 x64.
   Общедоступное программное обеспечение.

7. Microsoft(R) Visual C++ 2015 Community Compiler.
   Общедоступное программное обеспечение.

8. GNU C++ compiler g++ 2.9.6
   Общедоступное программное обеспечение.

9. GNU C++ compiler g++ 4.1.2
   Общедоступное программное обеспечение.


1.6. Техническая поддержка
--------------------------

Обеспечивается на сайте http://www.imach.uran.ru/cbignum

Просьба отсылать автору свoи конструктивные предложения,
а также сообщения об ошибках и проблемах совместимости.


1.7. Контактная информация
--------------------------

Автор:  к.т.н. Рауль Нурович Шакиров
620219, Россия. г.Екатеринбург, ул.Комсомольская, 34,
Институт Машиноведения УрО РАН.

Тел.:   +7 (343) 375-35-65
Почта:  raul@imach.uran.ru


1.8. Благодарности
------------------

Автор выражает благодарность к.ф-м.н. Н.В.Невесенко за обсуждение
идей в области алгоритмов целочисленных вычислений.


2. Состав дистрибутива
======================

Класс cBigNumber реализован в виде следующих файлов:

   Cbignum.cpp  - реализация методов класса cBigNumber
   Cbignum.h    - декларации и inline - функции класса cBigNumber
   Cbignum.txt  - руководство по применению класса (англ.)
   Cbignumr.txt - руководство по применению класса (рус.)
   Cbignumf.cpp - реализация базовых арифметических функций над
                  неограниченными числами с применением машинных
                  команд (в дополнительном пакете)
   Cbignumf.inl - реализация базовых арифметических функций
                  над неограниченными числами на стандартном C++
   Cbignumf.h   - макропараметры для базовых арифметических функций
   Cbignums.cpp - реализация операторов потокового ввода-вывода
   Cbignums.h   - декларации операторов потокового ввода-вывода
   Cbnl.h       - декларации для определения компилятора
   Cbnl.inl     - декларации для определения компилятора
   Cbnl64.inl     (в дополнительном пакете)
   Cios.h       - декларации стандартного потокового ввода-вывода
   Cthr.h       - декларации для поддержки многопоточности
   Ctty.cpp     - обработчики независимого потокового вывода
   Ctty.h       - класс для независимого потокового вывода
   Ctty.txt     - руководство по применению класса (рус.)
   Cttyr.txt    - руководство по применению класса (англ.)
   Exarray.cpp  - функции распределения памяти
   Exarray.h    - шаблон динамических массивов
   Exarray.txt  - руководство по применению шаблона (англ.)
   Exarrayr.txt - руководство по применению шаблона (рус.)
   Exdebug.h    - отладочные макросы шаблона
   Exstring.h   - переопределения функций string.h
   Exthread.h   - макро локальной памяти потока
   Prime.cpp    - тестовые функции для определения простых чисел
   ENG\         - исходные коды с комментариями (англ.)
   RUS\         - исходные коды с комментариями (рус.)

Дополнительный пакет также содержит:
   Cbnl32.obj   - 32-разрядный объектный файл
   Cbnl64.obj   - 64-разрядный объектный файл

Файл Cbignumr.txt описывает документированные функции класса,
которые будут сохранены в последующих версиях класса, если
только в соответствующем разделе не оговорено противное.

Для удобства изучения в файлы *.cpp и *.h встроены
комментарии, которые могут рассматриваться, как
дополнительная документация. Если программисты будут
испытывать затруднения при ознакомлении с текстами,
то автор всегда будет рад им помочь.

ПРЕДУПРЕЖДЕНИЕ:
Все определения файлов *.cpp и *.h, не обеспечивающие
штатные операции языка C++ и не перечисленные в
файле Cbignumr.txt, считаются недокументированными.
Они могут быть исключены или модифицированы в
последующих реализациях без каких-либо уведомлений.


2.1. Тестовые программы
-----------------------

Тестовые программы скомпилированы в 32-разрядном и 64-разрядном
режимах для операционных систем Windows и Linux. Также доступны
специальные 64-разрядные программы для процессоров с расширенным
набором инструкций BMI2 (Intel Haswell/AMD Excavator).

ПРИМЕЧАНИЕ: Наличие поддержки BMI2 определяется в коде класса по
            макро __AVX2__ при компиляции под Microsoft Visual C++.

На больших числах программы для Windows работают в несколько
раз быстрее, чем соответствующие программы для Linux,
т.к. компиляция для Windows проводилась с использованием
встроенного ассемблера.

Для сборки всех программ можно использовать следующие файлы:

   Cbignum      - команды для GNU g++
   Cbignum.dsw  - рабочая область Microsoft Visual C++ 6.0
   Cbignumd     - команды для GNU g++ (отладочный режим)

Тестовые программы и инструкции сборки для PocketPC включены
в дополнительный пакет.


2.1.1. Целочисленный калькулятор Arifexp
----------------------------------------

Программа Arifexp выполняет арифметические вычисления, которые
задаются в виде следующих выражений:
a=      (вывести число)
a+b=    (сложение)
a-b=    (вычитание)
a*b=    (умножение)
a/b=    (деление с остатком)
a%b=    (остаток)
a\b=    (степень)
a<<b=   (сдвиг влево)
a>>b=   (сдвиг вправо)
a|b=    (дизъюнкция)
a&b=    (конъюнкция)
a^b=    (исключающее или)
a?b=    (сравнение, выдает -1,0,1)
a+b*c=  (умножение со сложением)
a-b*c=  (умножение с вычитанием)
a\b%c=  (степень по модулю)
2Vb=    (квадратный корень с остатком)
После каждого числа может стоять суффикс R, который заказывает
генерацию случайного числа с заданным знаком и числом значащих бит.

Между операндами и знаками операций разрешается добавлять пробелы,
табуляции и переводы строк. За раз можно задать несколько выражений,
которые вычисляются независимо друг от друга.

При запуске программы можно указать следующие опции:
-idle   низкий приоритет
-high   высокий приоритет
-par n  выполнять до n параллельных потоков (сейчас 1 или 2)
-hex    шестнадцатеричный ввод/вывод
-hexi   шестнадцатеричный ввод
-hexo   шестнадцатеричный вывод
-div0   разрешить деление на 0
-rand   подставлять случайные числа указанной длины вместо вычисления
    all включая подстановку для показателей степени и сдвига
      0 подставлять -8,-4,-2,-1,0,1,2,4,8 вместо 0
-exp n  добавить до n нулей к случайным числам
-dn  n  выровнять код до n слов, если это возможно без изменения значения
-size   показывать старшее слово и размер чисел
-time   показывать оценку времени операции в машинных циклах Athlon
-mhz n  тактовая частота CPU для оценки времени операции в миллисекундах
-rep n  повторять операцию n раз
-v      выводить выражение перед результатом
-check  проверять результат операций, если это возможно
-help   справка о программе

Опции приоритета и параллельности поддерживаются только под Windows
в зависимости от компилятора. Если они активированы, то программа
сообщает "Idle priority", "High priority" или "Run concurrent thread
for output".

После опций можно указать имя файла с выражениями.

   ПРИМЕЧАНИЕ: Для формирования и запуска теста можно воспользоваться
               следующими командами:
   Arifexp -rand >input
   Arifexp input >output

Программа выдает код возврата:
    0 - нормальное завершение
    1 - обнаружена ошибка в результате операции (опция -check)
  255 - обнаружена ошибка в опциях или исходных данных

Состав программы:

   Arif          - тест
   Arif.bat      - запуск теста
   Arif.res      - эталон для сравнения с результатом
   Arif.sh       - запуск теста под Linux
   Arif.wrk      - результат

   Arif1         - тест умножения с накоплением
   Arif1.bat     - запуск теста
   Arif1.res     - эталон для сравнения с результатом
   Arif1.sh      - запуск теста под Linux
   Arif1.wrk     - результат

   Arif2         - тест возведения в степень по модулю
   Arif2.bat     - запуск теста
   Arif2.res     - эталон для сравнения с результатом
   Arif2.sh      - запуск теста под Linux
   Arif2.wrk     - результат

   Arif3         - тест умножения
   Arif3.bat     - запуск теста
   Arif3.res     - эталон для сравнения с результатом
   Arif3.sh      - запуск теста под Linux
   Arif3.wrk     - результат

   Arif4         - тест деления с остатком
   Arif4.bat     - запуск теста
   Arif4.res     - эталон для сравнения с результатом
   Arif4.sh      - запуск теста под Linux
   Arif4.wrk     - результат

   Arif5         - тест квадратного корня с остатком
   Arif5.bat     - запуск теста
   Arif5.res     - эталон для сравнения с результатом
   Arif5.sh      - запуск теста под Linux
   Arif5.wrk     - результат

   Arifr         - шаблон теста
   Arifr.bat     - запуск теста генератора случайных чисел
   Arifr.sh      - запуск теста генератора случайных чисел под Linux
   Arifr.wrk     - последний полученный результат

   Arifrand      - шаблон теста
   Arifrand.1    - тест с короткими случайными числами
   Arifrand.2    - тест с длинными случайными числами
   Arifrand.b1   - Arifrand.1 для последнего некорректного результата
   Arifrand.b2   - Arifrand.2 для последнего некорректного результата
   Arifrand.bad  - последний некорректный результат (см. NO MATCH)
   Arifrand.bat  - запуск циклического теста под Windows
   Arifrand.res  - накопитель кодов возврата для циклов теста
   Arifrand.sh   - запуск циклического теста под Linux
   Arifrand.wrk  - последний полученный результат

   Arifexp       - исполняемый файл программы для Linux
   Arifexp.cpp   - текст программы
   Arifexp.dsp   - файл проекта для Microsoft Visual C++ 6.0
   Arifexp.exe   - исполняемый файл программы для Win32
   Arifexp.prj   - файл проекта для Borland C++ 3.1
   Arifexp64     - исполняемый файл программы для Linux x64
   Arifexp64.exe - исполняемый файл программы для Win64
   Arifexp64x.exe- исполняемый файл программы для Win64 BMI2

   Gettimer.c   - функции для замера производительности
   Gettimer.h     и установки приоритета

   Random3.c    - генератор случайных чисел
   Random3.h
   Random3.txt  - документация (англ.)
   Random3r.txt - документация (рус.)

Тестов Arif1-Arif5 оценивают число циклов CPU, требуемое для решения
задачи; если требуется получить оценку в миллисекундах, то задайте
переменную окружения MHZ с частотой CPU, например:
   SET MHZ=2000

ПРИМЕЧАНИЕ: При запуске тестов автоматически выбираются 32-разрядные или
            64-разрядные программы в зависимости от типа операционной
            системы, но не выбираются автоматически программы для BMI2;
            для выбора программ BMI2 надо отредактировать тесты вручную.


2.1.2. Программа перемножения квадратных матриц Matrix
------------------------------------------------------

Программа перемножения квадратных матриц реализована
с использованием чисел cBigNumber и шаблона динамических
массивов exarray, положенного в основу класса cBigNumber.

Программа демонстрирует современную технику программирования,
при которой отсутствует необходимость управления распределением
памяти со стороны программиста, т.к. динамические массивы
exarray имеют неограниченные размеры по всем измерениям.
На взгляд автора, идея неограниченного массива удачно дополняет
концепцию чисел без ограничения разрядности.

В тексте программы предусмотрены макроопределения, позволяющие
при компиляции отказаться от динамических массивов в пользу
обыкновенного статического распределения памяти, а также
поменять формат представления чисел.

Состав программы:

   10            - исходные данные для перемножения матриц 10*10
   10.bat        - тест перемножения матриц 10*10
   10.res        - эталон для сравнения с результатом перемножения
   10.sh         - тест перемножения матриц 10*10 под Linux
   10.wrk        - результат перемножения

   100           - исходные данные для перемножения матриц 100*100
   100.bat       - тест перемножения матриц 100*100
   100.res       - эталон для сравнения с результатом перемножения
   100.sh        - тест перемножения матриц 100*100 под Linux
   100.wrk       - результат перемножения

   Gettimer.c    - функции для замера производительности
   Gettimer.h      и установки приоритета.

   Matrix        - исполняемый файл программы для Linux
   Matrix.cpp    - текст программы
   Matrix.dsp    - файл проекта для Microsoft Visual C++ 6.0
   Matrix.exe    - исполняемый файл программы для Win32
   Matrix.prj    - файл проекта для Borland C++ 3.1
   Matrix.txt    - инструкция по подготовке исходных данных (ангп.)
   Matrix64      - исполняемый файл программы для Linux x64
   Matrix64.exe  - исполняемый файл программы для Win64
   Matrix64x.exe - исполняемый файл программы для Win64 BMI2
   Matrixr.txt   - инструкция по подготовке исходных данных (рус.)


2.1.3. Программа определения простых чисел Miller
-------------------------------------------------

Программа Miller запрашивает число и определяет его простоту
по методике, изложенной на странице
   http://www.utm.edu/research/primes/prove/prove3.html
Диалог ведется на английском языке.

При запуске программы можно указать следующие опции:
-idle   низкий приоритет
-high   высокий приоритет
-hex    шестнадцатеричный ввод/вывод
-hexi   шестнадцатеричный ввод
-hexo   шестнадцатеричный вывод
-factor факторизация по методу "грубой силы" (самый медленный тест)
-proved быстрый тест SPRP 2..17 и факторизация  (быстрее и не хуже)
-miller факторизация по 2..7919 и полный тест Миллера (еще быстрее)
-strong факторизация по 2..7919 и SPRP 2..17 (очень быстрый, вероятностный)
-scan n проверить указанное число значений с шагом 2
-help   справка о программе
После опций можно указать имя файла с проверяемым числом.

Если способ проверки не выбран, то проводится два независимых теста:
вероятностный по Миллеру и факторизация. При корректной работе программы
результаты этих двух тестов не должны противоречить друг другу.

Программа выдает код возврата:
    0 - составное
    1 - простое по поиску делителей
    2 - простое по малым SPRP
    3 - возможно простое по Миллеру
    7 - возможно простое по малым SPRP
   11 - простое по поиску делителей, но SPRP-составное (ошибка)
   12 - простое по малым SPRP, но есть делитель        (ошибка)
   13 - возможно простое по Миллеру, но есть делитель  (ошибка)
  255 - обнаружена ошибка в опциях или входных данных
Если с опцией scan проверено несколько чисел, то выдается
максимальный код.

Состав программы:

   Gettimer.c    - функции для замера производительности
   Gettimer.h      и установки приоритета.

   Mill.bat      - запуск тестов для чисел Miller.9 - Miller.1
   Mill.sh       - запуск тестов для чисел Miller под Linux
   Miller        - исполняемый файл программы для Linux
   Miller.1      - большое простое число:
                   тест не доходит до конца, но по нему можно
                   судить о степени вероятности...
   Miller.2-9    - числа поменьше и попроще.
   Miller.cpp    - текст программы
   Miller.dsp    - файл проекта для Microsoft Visual C++ 6.0
   Miller.exe    - исполняемый файл программы для Win32
   Miller.prj    - файл проекта для Borland C++ 3.1
   Miller64      - исполняемый файл программы для Linux x64
   Miller64.exe  - исполняемый файл программы для Win64
   Miller64.exe  - исполняемый файл программы для Win64 BMI2

   Millrand      - шаблон теста
   Millrand.1    - случайное число
   Millrand.2    - случайное нечетное число для теста
   Millrand.b1   - Millrand.1 для последнего некорректного результата
   Millrand.b2   - Millrand.2 для последнего некорректного результата
   Millrand.bad  - последний некорректный результат (см. NO MATCH)
   Millrand.bat  - запуск циклического теста под Windows
   Millrand.res  - накопитель кодов возврата для циклов теста
   Millrand.sh   - запуск циклического теста под Linux
   Millrand.wrk  - последний полученный результат


3. Правила применения
=====================

Для применения класса cBigNumber следует:

1.  Разместить в рабочем каталоге файлы:
        Cbignum.cpp
        Cbignum.h
        Cbignumf.cpp
        Cbignumf.h
        Cbignumf.inl
        Cbignums.cpp (опция для операций потокового ввода-вывода)
        Cbignums.h   (опция для операций потокового ввода-вывода)
        Cbnl.h
        Cbnl.inl
        Cbnl64.inl
        Cios.h       (опция для поддержка ввода-вывода)
        Ctty.cpp     (опция для операций вывода на консоль)
        Ctty.h
        Exarray.cpp
        Exarray.h
        Exdebug.h
        Exthread.h
        Prime.cpp    (опция для проверки чисел на простоту)
    Если используется дополнительный пакет, то в рабочий каталог
    добавить файл:
        Cbnl32.obj   (для 32-разрядного режима компиляции,
                      если в Cbnl.inl установлено макро _CBNL_ML)
        Cbnl64.obj   (для 64-разрядного режима компиляции,
                      если в Cbnl64.inl установлено макро _CBNL_ML)

2.  Включить в проект файлы:
        Cbignum.cpp
        Cbignumf.cpp
        Cbignums.cpp (опция для операций потокового ввода-вывода)
        Ctty.cpp     (опция для операций вывода на консоль)
        Exarray.cpp
        Prime.cpp    (опция для проверки чисел на простоту)
    Если используется дополнительный пакет, то добавить в проект файл:
        Cbnl32.obj   (для 32-разрядного режима компиляции,
                      если в Cbnl.inl установлено макро _CBNL_ML)
        Cbnl64.obj   (для 64-разрядного режима компиляции,
                      если в Cbnl64.inl установлено макро _CBNL_ML)

    ПРИМЕЧАНИЕ: Опциональные файлы потокового ввода-вывода и вывода
                на консоль используют библиотеку потокового ввода-вывода
                языка C++, которая существует в двух вариантах: старом
                (iostream.h) и стандартном (iostream). Старые компиляторы
                могут не иметь стандартную библиотеку, в то время как
                новые выдают для старой библиотеки предупреждения или
                вообще не включают ее начиная с Microsoft Visual C++ 2005.
                А если компилятор Microsoft допускает обе библиотеки, то
                во всем проекте может использоваться только одна из них
                т.к. их совместное использование не допускается.

                По умолчанию класс подключает старую библиотека, за
                исключением случаев применения компиляторов Microsoft
                Visual C++ NET, 2003-2017 и выше, GNU g++ 3.x, 4.x и выше.
                Чтобы изменить умолчание, надо добавить в настройки
                компилятора макро:
                  _CIOS_STDSTREAM (стандартная библиотека)
                  _CIOS_OLDSTREAM (старая библиотека)

3.  Добавить в тексты программных модулей директивы:
        #include "Cbignum.h"
        #include "Cbignums.h" (для операций потокового ввода-вывода)

Максимальная скорость вычислений обеспечивается в том случае, если при
компиляции программы задано макро NDEBUG. Более подробная информация
приведена в разделах 4.6 и 5.1. Макро NDEBUG задается по умолчанию
при компиляции под Visual C++ в режиме Release; если компиляция ведется
по командной строке, то макро можно задать в опциях.

Например, для компиляции программы Arifexp (раздел 2.1.1) под Linux
можно использовать следующие команды:

Отладочный режим:
   g++ Arifexp.cpp Cbignum.cpp Cbignumf.cpp Cbignums.cpp
       Ctty.cpp Exarray.cpp Gettimer.c Random3.c -o Arifexp

Рабочий режим:
   g++ -O5 -DNDEBUG Arifexp.cpp Cbignum.cpp Cbignumf.cpp Cbignums.cpp
       Ctty.cpp Exarray.cpp Gettimer.c Random3.c -o Arifexp


ПРИМЕЧАНИЕ: Настоящая версия класса приспособлена для компиляции под
            Borland C++, Microsoft Visual C++ и GNU g++ (версии 3.3
            или выше для многопоточных приложений). Если применяется
            другой транслятор, то для получения более производительного
            кода рекомендуется определить макро EXTHREAD_LOCAL как
            описано ниже.

            Для трансляции однопоточных приложений макро EXTHREAD_LOCAL
            должно содержать либо пустое значение, либо зависящий от
            транслятора префикс локальной памяти потока (обычно __thread).

            Для трансляции многопоточных приложений макро EXTHREAD_LOCAL
            должно содержать зависящий от транслятора префикс локальной
            памяти потока (обычно __thread). Убедитесь по документации,
            что применяемый транслятор поддерживает локальную память
            потока (thread local storage). Если это не так, то макро
            EXTHREAD_LOCAL определять НЕ НАДО, чтобы провести компиляцию
            приложения в режиме совместимости.

            Отметим, что программа, которая транслируется в режиме
            совместимости, может работать значительно медленнее на
            небольших числах, к примеру, Matrix в разделе 2.1.2.
            См. также раздел 4.2.4.


3.1. Объявление неограниченных чисел и штатные операции C++
-----------------------------------------------------------

1.  Длинное целое число объявляется, как
        cBigNumber num

2.  Начальные значения cBigNumber могут задаваться с помощью
    выражений, а также конструкторов присваивания числа или
    строки.

    Конструктор присваивания числа ограничен диапазоном
    чисел типа long со знаком:
        cBigNumber num = 2147483647;
    На 64-разрядных компиляторах допускается также присваивание
    констант типа i64, там, где они поддерживаются:
        cBigNumber num = 2147483648i64;
    Для присваивания i64 тип CBNL должен быть объявлен в файле
    Cbnl.h как 64-разрядный, в исходном варианте файла это
    сделано для всех компиляторов с 64-разрядным типом long
    и дополнительной для Visual C++ в 64-разрядном режиме.

    Конструктор присваивания строки не ограничивает диапазон.
    Он требует явного указания основания системы счисления в
    пределах от 2 до 16 или равного нулю. Нуль подразумевает
    десятичную, восьмеричную или шестнадцатеричную константу
    языка C, например:
        cBigNumber num ("0x80000000", 0):

    Выражения и конструкторы могут применяться для объявления
    длинных констант, например:
        const cBigNumber big_const ("2147483648", 10);

3.  Класс реализует все возможности штатной арифметики языка C++,
    включая арифметические, логические и побитовые операции,
    операции сравнения, сдвиги, а также операторы потокового
    ввода-вывода со всеми целочисленными модификаторами.
    Поддерживаются комбинированные операции над неограниченными
    числами и целыми числами со знаком. Поэтому правила обработки
    неограниченных чисел в основном совпадают с правилами
    целочисленной знаковой арифметики языка C.

* Важные особенности реализации, включая особенности операций
  над беззнаковыми (unsigned) числами и числами с плавающей
  точкой описаны в разделе 5.2.


3.2. Дополнительные операции, функции и методы
----------------------------------------------

Операции c результатом в стеке.
   cBigNumber (s,radix) Формирование числа из символьной строки s по
                        основанию radix от 2 до 16 или 0, последнее
                        подразумевает десятичную, восьмеричную или
                        шестнадцатеричную константу языка C, т.е.
                        шестнадцатеричную после префикса 0x/0X,
                        восьмеричную после 0, иначе десятичную.
   cBigAbs    (a)       Абсолютное значение a.
   cBigUnsign (a)       Беззнаковое значение a (все биты значащие).
   cBigPow    (a,b)     Возведение а в степень b.
   cBigPowMod (a,b,mod) Возведение a в степень b по модулю mod.
   cBigSqrt   (a)       Целая часть квадратного корня a.
   cBigBits   (a)       Число значащих бит в двоичном дополнительном коде a.
        Значащими считаются самый старший бит, отличный от
        знакового бита и все младшие по отношению к нему биты.
        Например, у 0 и -1 нет значащих битов, 1 и -2 имеют
        1 значащий бит, числа 127 и -128 имеют 7 значащих бит.
        Модуль числа с n значащими битами не больше 2 в степени n.
   cBigExBits (a)       Число значащих младших 0-бит в двоичном коде a.
        К младшим 0-битам относятся все значащие биты, младшие
        по отношению к младшему ненулевому биту.
        Например, у 0 и всех нечетных чисел нет младших 0-битов,
        2 и -2 имеют 1 младший 0-бит, 128 и -128 имеют 7 младших 0-битов.
        Модуль числа с n младшими 0-битами не меньше 2 в степени n.
   cBigRandom (rand,n)  Случайное число с числом значащих бит до n.
        Для формирования случайного числа используется внешний
        генератор rand без параметров, возвращающий случайное
        число без знака с равномерным распределением в диапазоне
        0..ULONG_MAX. Инициализируйте генератор, как описано в
        его документации. Для примера см. файл Random3r.txt.

Операции с результатом в стеке и сохранением остатка в 1-ом аргументе.
   cBigDivMod (a,b)     Целочисленное деление a/b, остаток заносится в а.
   cBigSqrtRm (a)       Целая часть квадратного корня a, остаток в а.

Консольные потоки и методы.
   cBigNumberMessages   Поток консольных сообщений.
   cBigNumberProgress   Поток консольных прогресс-индикаторов.
        Здесь потоки - это объекты класса cTTY, которые задействуются
        различными методами и функциями для вывода на консоль.
        В поток можно вывести оператором << символы, строки и числа
        с знаком, включая неограниченные числа cBigNumber. Имеются
        методы для форматированного вывода (см. файл Cttyr.txt).

   ВНИМАНИЕ:   По умолчанию, вывод на консоль отключен. Чтобы его
               включить, надо добавить в проект исполняемый файл
               Ctty.cpp и присвоить потокам обработчики:
                        cBigNumberMessages = cTTY_StandardOutput;
                        cBigNumberProgress = cTTY_ProgressOutput;

   ПРИМЕЧАНИЕ: Поскольку это глобальные переменные, присваивайте
               им обработчики только в основном потоке программы.

   a.dump     ()        Шестнадцатеричный вывод массива слов на cout
                        в порядке от старших слов к младшим.
   a.info     ()        Короткий дамп со старшим словом и числом слов.
   a.erange   ()        Сообщение "cBigNumber value out of range" с
                        коротким дампом и завершением по abort().

   ПРИМЕЧАНИЕ: Данные методы ничего не выводят, если не был
               установлен обработчик cBigNumberMessages.

Доступ к машинному представлению числа.
   a.length   ()        Число слов типа CBNL в дополнительном коде.
   a.code     ()        Массив слов типа CBNL с дополнительным кодом,
                        младшее слово имеет индекс 0.
        Метод code() выдает константный указатель, который действителен
        до тех пор, пока над числом не выполняются арифметические
        операции или операции распределения памяти.
        Для доступа к коду по записи преобразуйте указатель в CBNL*.

        Чтобы изменить число слов, запишите его в элемент с индексом -1.
        Число слов можно уменьшать до 1 или увеличивать в пределах
        распределенного под число участка памяти (см. раздел 3.3).
        Для лучшей производительности рекомендуется нормализовать
        код так, чтобы он имел минимально необходимое число слов.
        Нормализацию можно обеспечить вызовом метода fit(). Пример
        кода см. в разделе 5.2.

        ПРИМЕЧАНИЕ: Число со значением 0 может состоять из 1-го
                    слова со значением 0 или из 0 слов.

   a.fit      ()        Нормализация.
        Нормализация состоит в удалении лишних нулевых или единичных
        старших слов. Она не нужна для чисел полученных исключительно
        методами класса, т.к. все они нормализованы. Отметим, что
        ненормализованные числа корректно обрабатываться всеми методами
        класса, но полученный таким образом результат не обязательно
        будет нормализованным.

        ПРИМЕЧАНИЕ: 0 имеет две нормализованные формы - стандартную из
                    1-го слова и компактную из 0 слов (компактная форма
                    позволяет не распределять динамическую память).
                    Метод fit() преобразует компактный 0 в стандартный.

   a.loword   ()        Младшее CBNL слово дополнительного кода.
   a.hiword   ()        Старшее CBNL слово дополнительного кода.
        Оба метода работают для числа 0 из 0 слов, возвращая 0.
        Метод hiword() выдает старшее слово кода без учета нормализации
        числа т.е. если в коде есть лишние 0 или ~0 слова, то выдается
        соответственно 0 или ~0.
   a.words    ()        Число значащих слов в дополнительном коде.
        Значащими считаются самое старшие слово, содержащее не
        только знаковый бит и биты его расширения и все младшие
        по отношению к нему слова.
   a.exwords  ()        Число значащих младших 0-слов в дополнительном коде.
        К младшим 0-словам относятся все значащие слова,
        младшие по отношению к младшему ненулевому слову.
        Если все слова нулевые, то младших 0-слов нет.

Информация о числе с проверкой диапазона.
   a.bits     ()        Число значащих бит в двоичном дополнительном коде.
   a.exbits   ()        Число значащих младших 0-бит в двоичном коде.
        Методы выдают значение типа CBNL, если число бит > CBNL_MAX,
        то после диагностики вызывается abort().

Преобразование числа с проверкой диапазона.
   a.toCBNL   ()        Преобразование в целое число типа CBNL.
   a.tolong   ()        Преобразование в целое число типа long.
   a.toint    ()        Преобразование в целое число типа int.
   a.toshort  ()        Преобразование в целое число типа short.
        Если число не помещается, то после диагностики вызывается abort().

Преобразование числа в строку.
   a.toa (str)          Формирование десятичного представления числа.
   a.toa (str,radix)    Формирование символьного представления числа
                        с основанием radix в пределах от 2 до 16.
   Здесь str - объект класса cBigString, который автоматически
   преобразуется в const char*, например:
        cBigString str;
        a.toa (str);
        cout << str;
   Метод toa() возвращает char* на содержимое объекта cBigString.
   Указатель актуален, пока объект cBigString не изменяется, например:
        cBigString str;
        cout << a.toa (str);

Исключенный нереентерабельный метод (не применяйте).
   a.toatmp   ()        Формирование десятичного представления числа
                        в статическом буфере (*).
   a.toatmp   (radix)   Формирование символьного представления числа
                        в статическом буфере (*) с основанием radix
                        в пределах от 2 до 16.
(*) Статический буфер перетирается при каждом вызове toatmp().

   ПРИМЕЧАНИЕ: Данный метод недоступен, если в файле Cbignum.h включено
               макро _CBIGNUM_MT и не включено макро _CBIGNUM_TOATMP,
               что сделано по умолчанию начиная с версии класса 1.2c.
               Замените этот метод на метод toa().


3.3. Функции и методы для ручной оптимизации программ
-----------------------------------------------------

Сравнение.
   a.comp     (b)       0 при a == b; -1 при a < b; 1 при a > b
   a.comp     ()        0 при a == 0; -1 при a < 0; 1 при a > 0

Операции с накоплением результата.
   a.neg      ()        Обращение знака.
   a.add      (b)       Быстрое сложение  (*).
   a.sub      (b)       Быстрое вычитание (*).
   a.mul2     ()        Умножение на 2.
   a.div2     ()        Деление на 2 (целая часть).
   a.pow2     ()        Возведение в квадрат.
   a.pow      (b)       Возведение в степень.
   a.powmod   (b,mod)   Возведение в степень по модулю mod.
   a.sqrt     ()        Целая часть квадратного корня.
(*) Оптимизированы для операнда размером не менее 3 слов и
    аккумулятора размером не меньше операнда. То же что += и -=.

Комбинированные операции с накоплением результата.
   c.addmul   (a,b)     Умножение с накоплением c += a * b.
   c.submul   (a,b)     Умножение с накоплением c -= a * b.

Операции с присваиванием результата переменной c.
   c.set      (a)       Копирование.
   c.set      (s)       Формирование числа по десятичному представлению
                        в символьной строке s.
   c.set      (s,radix) Формирование числа из символьной строки s по
                        основанию radix от 2 до 16 или 0, последнее
                        подразумевает десятичную, восьмеричную или
                        шестнадцатеричную константу языка C, т.е.
                        шестнадцатеричную после префикса 0x/0X,
                        восьмеричную после 0, иначе десятичную.
   c.setneg   (a)       Обращение знака.
   c.setcompl (a)       Побитовая инверсия.
   c.setxor   (a,b)     Побитовая сумма по модулю 2.
   c.setand   (a,b)     Побитовая конъюнкция.
   c.setor    (a,b)     Побитовая дизъюнкция.
   c.setadd   (a,b)     Сложение.
   c.setsub   (a,b)     Вычитание.
   c.setmul   (a,b)     Умножение.
   c.setdiv   (a,b)     Деление (целая часть).
   c.setmod   (a,b)     Остаток от деления.
   c.setshl   (a,b)     Сдвиг влево.
   c.setshr   (a,b)     Сдвиг вправо.
   c.setpow   (a,b)     Степень.
   c.setpowmod(a,b,mod) Степень по модулю mod.
   c.setsqrt  (a)       Целая часть квадратного корня.
   c.setbits  (a)       Число значащих бит в двоичном дополнительном коде.
   c.setexbits(a)       Число значащих младших 0-бит в двоичном коде.
   c.setrandom(rand,n)  Случайное число с числом значащих бит до n.

Комбинированные операции с присваиванием результата переменным c и a.
   c.setdivmod(a,b)     Деление с остатком           (остаток заносится в a).
   c.setsqrtrm(a)       Квадратный корень с остатком (остаток заносится в а).

   ПРИМЕЧАНИЕ: Переменные a и c не должны перекрываться.

Комбинированные операции c применением таблицы сдвигов.
   a.tab      ()        Нормализация и формирование таблицы сдвигов.
   a.smp      ()        Нормализация и формирование таблицы сдвигов,
                        если не задействовано аппаратное умножение.

   ПРИМЕЧАНИЕ: Таблица сдвигов не мешает обычному использованию
               числа. Она остается актуальной до тех про, пока
               число не примет результат какой-либо операции.

   c.addmultab    (a,b) Умножение с накоплением c += a * b.
   c.submultab    (a,b) Умножение с накоплением c -= a * b.
                        Множимое a должно иметь таблицу сдвигов.
                        Множитель b должен быть неотрицательным.
                        Операнды не должны перекрываться с буфером
                        результата c.

   ПРИМЕЧАНИЕ: Методы addmultab() и submultab() не используют блочное
               умножение и быстрое аппаратное умножение. Это устаревшие
               методы, вместо них рекомендуется использовать методы
               addmulsmp() и submulsmp().

   c.addmulsmp    (a,b) Умножение с накоплением c += a * b.
   c.submulsmp    (a,b) Умножение с накоплением c -= a * b.
                        Множимое a должно быть после smp() или tab().
                        Множитель b должен быть неотрицательным.
                        Операнды не должны перекрываться с буфером
                        результата c.

   ПРИМЕЧАНИЕ: Методы addmulsmp() и submulsmp() используют быстрое
               аппаратное умножение, если оно задействовано, и таблицу
               сдвигов, если аппаратное умножение недоступно. В обоих
               случаях они не используют блочное умножение, рассчитанное
               на большие числа и потому имеют меньшие накладные расходы
               на небольших числах размером не более 3000-6000 бит.
               Если хотя бы один операнд небольшой, то эти методы могут
               быть не несколько процентов быстрее addmul() и submul().

   c.setdivtab    (a,b) Деление c = a / b (целая часть).
   c.setmodtab    (a,b) Остаток c = a % b.
                        Операнды должны иметь одинаковый знак.
                        Делитель b должен иметь таблицу сдвигов и
                        не должен перекрываться с буфером результата c.

   c.divtab         (b) Деление a /= b (целая часть).
   c.modtab         (b) Остаток a %= b.
                        Операнды должны иметь одинаковый знак.
                        Делитель b должен иметь таблицу сдвигов и
                        не должен перекрываться с делимым a.

   c.setdivmodtab (a,b) Деление с остатком c = a / b, a %= b.
                        Операнды должны иметь одинаковый знак, не должны
                        перекрываться друг с другом и буфером результата c.
                        Делитель b должен иметь таблицу сдвигов.

   ПРИМЕЧАНИЕ: У этих методов деления накладные расходы меньше, чем
               у общих методов setdiv(), setmod() и setdivmod() при условии,
               что делитель содержит более _CBIGNUM_SMALL_DIV слов, но для
               делителей меньшего размера они намного менее эффективны.

Машинно-зависимые операции (зависят от размера машинного слова).
   c.set       (a,n)    Копирование c = a сдвинутое влево на n слов.
   c.setr      (a,n)    Копирование c = a сдвинутое вправо на n слов.
   c.add       (a,n)    Быстрое сложение  c += a сдвинутое влево на n слов.
   c.sub       (a,n)    Быстрое вычитание c -= a сдвинутое влево на n слов.

   c.addmultab (a,b,n)  Умножение c += a * b сдвинутое влево на n слов.
   c.submultab (a,b,n)  Умножение c -= a * b сдвинутое влево на n слов.
                        Множимое a должно иметь таблицу сдвигов.
                        Множитель b должен быть неотрицательным.
                        Операнды не должны перекрываться с буфером
                        результата c.

   ПРИМЕЧАНИЕ: См. выше в перечне комбинированных операций.

   c.addmulsmp (a,b,n)  Умножение c += a * b сдвинутое влево на n слов.
   c.submulsmp (a,b,n)  Умножение c -= a * b сдвинутое влево на n слов.
                        Множимое a должно быть после smp() или tab().
                        Множитель b должен быть неотрицательным.
                        Операнды не должны перекрываться с буфером
                        результата c.

   ПРИМЕЧАНИЕ: См. выше в перечне комбинированных операций.

   c.divtab       (b,n) Деление a /= b после сдвига b влево на n слов.
   c.modtab       (b,n) Остаток a %= b после сдвига b влево на n слов.
                        Операнды должны иметь одинаковый знак.
                        Делитель b должен иметь таблицу сдвигов и
                        не должен перекрываться с делимым a.

   c.setdivtab  (a,b,n) Деление c = a / b после сдвига b влево на n слов.
   c.setmodtab  (a,b,n) Остаток c = a % b после сдвига b влево на n слов.
                        Операнды должны иметь одинаковый знак.
                        Делитель b должен иметь таблицу сдвигов и
                        не должен перекрываться с буфером результата c.

   c.setdivmodtab       Деление с остатком c = a / b, a %= b
               (a,b,n)  после сдвига b влево на n слов.
                        Операнды должны иметь одинаковый знак, не должны
                        перекрываться друг с другом и буфером результата c.
                        Делитель b должен иметь таблицу сдвигов.

   ПРИМЕЧАНИЕ: См. выше в перечне комбинированных операций.

Распределение памяти.
   a.expand    (n)      Увеличить число доступных слов до оптимального
                        значения в диапазоне n..2n.

   ПРИМЕЧАНИЕ: Данная операция не изменяет число слов во внутреннем
               представлении числа. Затрагивается только число
               зарезервированных слов и только в сторону увеличения,
               т.е. если это число было изначально больше чем n,
               то оно не уменьшится.

Оптимизация использования памяти.
   a.gc        ()       Освободить избыточную память.
   a.pack      ()       Освободить всю память сверх минимально необходимой.
   a.clear     ()       Обнулить число и освободить всю выделенную память.

   ПРИМЕЧАНИЕ: Данные операции удаляют таблицу сдвигов. Технические детали
               освобождения памяти описываются в Разделе 4.3.

Управление делением (для применения в основном потоке программы).
   cBigNumber::maskdiv0   (0)   Запретить деление на 0
   cBigNumber::maskdiv0   (1)   Разрешить деление на 0 по правилу
                                частное = 0, остаток равен делимому (*).
                                Также разрешает возведение в степень по
                                модулю 0, которое будет возвращать 1.
   cBigNumber::testdiv0   ()    Было ли деление на 0?

   ПРИМЕЧАНИЕ: Поскольку эти методы являются статическими, используйте
               их только в основном потоке программы.

Исключенные нереентерабельные методы (не применяйте).
   cBigNumber::lastdivmod ()    Последний остаток, сформированный методами
                                /, /=, setdiv, setdivtab.
   cBigNumber::lastrootrm ()    Последний остаток, сформированный методами
                                cBigSqrt, sqrt, setsqrt.

   ПРИМЕЧАНИЕ: Данные статические методы недоступны, если в файле Cbignum.h
               включено макро _CBIGNUM_MT, что сделано по умолчанию начиная с
               версии класса 1.2c. Применяйте вместо них операции cBigDivMod()
               и cBigSqrtRm() или методы setdivmod() и setsqrtrm().


3.4. Определение простых чисел и факторизация
---------------------------------------------

Базовый тест.

   b_SPRP         (a,b) Тест "строго вероятной простоты" по основанию b.
                        Выдает: 0 = составное,
                                2 = возможно, простое,

   ПРИМЕЧАНИЕ: "Строго вероятные" простые числа по основанию 2 являются
               простыми с вероятностью 99.9999%. Тем не менее, рекомендуется
               комбинировать этот тест с пробным делением (см. ниже).

Простые тесты (prime.cpp).

   SPRP           (a)   Полный тест SPRP.
   SPRP           (a,b)         b = тест SPRP не прошел или не был проведен.
                        Выдает: 0 = составное (неё прошел последний тест),
                                2 = простое по начальным основаниям SPRP,
                                3 = возможно простое по Миллеру, т.е. простое,
                                    если верна обобщенная гипотеза Римана.

   FastSPRP       (a)   Тест SPRP для начальных оснований.
   FastSPRP       (a,b)         b = тест SPRP не прошел или не был проведен.
                        Выдает: 0 = составное (не прошел последний тест),
                                2 = простое по начальным основаниям SPRP,
                                7 = возможно простое, но может быть составным.

   LastSPRP       (a)   Тест Миллера для следующих оснований.
   LastSPRP       (a,b)         b = тест SPRP не прошел или не был проведен.
                        Выдает: 0 = составное (не прошел последний тест),
                                3 = возможно простое по Миллеру, т.е. простое,
                                    если верна обобщенная гипотеза Римана и
                                    при условии что пройден тест FastSPRP().

   ПРИМЕЧАНИЕ: Данная реализация доказывает простоту a < 341,550,071,728,321
               по тесту SPRP 2..17 и вероятную простоту для больших a
               по тесту SPRP 19..2297 и выше в зависимости от a.
               Основания до 1,373,639 простые, далее 2-3-SPRP простые.

   TestFactor     (a)   Тест факторизации по всевозможным делителям.
   TestFactor     (a,b)         b = найденный или не протестированный делитель.
                        Выдает: 0 = составное (делитель найден),
                                1 = простое.

   TestSmallFactor(a)   Тест факторизации по квадратичному и малым делителям.
   TestSmallFactor(a,b)         b = найденный или не протестированный делитель.
                        Выдает: 0 = составное (делитель найден),
                                1 = простое,
                               10 = малый делитель не найден.

   TestLargeFactor(a)   Тест факторизации по квадратичному и большим делителям.
   TestLargeFactor(a,b)         b = найденный или не протестированный делитель.
                        Выдает: 0 = составное (делитель найден),
                                1 = большой делитель не найден.

   ПРИМЕЧАНИЕ: Данная реализация использует таблицу простых чисел в
               пределах 2..7919 для a <= 62,837,329, а дальше таблицу
               факторизации для модуля 210. Квадратичный делитель и
               делители выше 7927 могут быть составными.

Комбинированные тесты в порядке от быстрых к медленным.

   IsStrongPrime  (a)   Быстрая факторизация и SPRP по начальным основаниям.
                        Выдает: 0 = составное,
                                1 = простое по факторизации,
                                2 = простое по начальным основаниям SPRP,
                                7 = возможно простое, но может быть составным.

   IsMillerPrime  (a)   Быстрая факторизация и полный тест SPRP.
                        Выдает: 0 = составное,
                                1 = простое по факторизации,
                                2 = простое по начальным основаниям SPRP,
                                3 = возможно простое по Миллеру, т.е. простое,
                                    если верна обобщенная гипотеза Римана.

   IsProvedPrime  (a)   SPRP по начальным основаниям и полная факторизация.
                        Выдает: 0 = составное,
                                1 = простое по факторизации,
                                2 = простое по начальным основаниям SPRP.

   IsPrime        (a)   Полные тесты SPRP и факторизации с двойной проверкой.
                        Выдает: 0 = составное (найден делитель),
                                1 = нет делителя и простое по SPRP,
                        ошибка 11 - нет делителя, но составное по SPRP,
                        ошибка 12 - простое по началу SPRP, но есть делитель,
                        ошибка 13 - простое по Миллеру, но есть делитель.


4. Рекомендации по применению
=============================

Исходное техническое задание, по которому создавался класс
и пояснительная записка находятся в Приложении 1.


4.1. Возможные области применения
---------------------------------

Класс разрабатывался на основе принципа максимального упрощения
внешнего интерфейса в соответствии со стандартом языка C++ и
обеспечения совместимости с различными аппаратно-программными
платформами. Класс характеризуется низкими накладными расходами
на распределение памяти и вызов вычислительных методов, а также
отсутствием ограничений на размер чисел.

Класс может быть рекомендован для любых применений, в которых
определяющим критерием является минимизация затрат времени на
разработку программы. Производительность класса и расход памяти
будут близки к оптимальным для операций над длинными числами
размером от 500 до 20,000 двоичных разрядов и машинными
32/64-разрядными числами.


4.2. Производительность
-----------------------

Наилучшие результаты по производительности получаются под
64-разрядными компиляторами на 64-разрядной Windows. 64-разрядный
код работает в 1.7-3 раза быстрее, чем 32-разрядный код.

Для увеличения производительности на платформе Windows следует
задействовать ассемблерную оптимизацию x386/x64, которая доступна
в виде дополнительного пакета. Ассемблерная оптимизация особенно
эффективна для процессоров AMD и Intel Core, где она дает 3-кратный
рост производительности на большинстве операций с большими числами,
включая операции накопления += и -=, умножения, деления, модуля,
возведения в степень, возведения в степень по модулю и извлечения
корня. Эффект оптимизации заметен в том случае, если слагаемое,
вычитаемое, один из множителей, делитель, результат степени или
основание корня состоит не менее чем из 3 слов. Для устаревших
процессоров Intel Pentium 4 эффект ассемблерной оптимизации
меньше - всего 1.5-кратный.

В последующих таблицах Arifexp с ассемблерной оптимизацией,
включенная в дистрибутив, сравнивается с:
- C-версиями Arifexp без ассемблерной оптимизации;
- специальной версией Arifexp для библиотеки NTL
  (http://www.shoup.net/ntl, версия 5.4).

32-разрядный ассемблерный код скомпилирован под Visual C++ 6.0
в режиме Release при установках оптимизации "Maximize Speed".
Результаты получены для версии класса 1.2b, производительность
которой на обсуждаемых примерах аналогична 32-разрядной
производительности последующих версий класса.

32-разрядный C++ код скомпилирован под Visual C++ 2010 Express
в режиме Release. Для тестов используется версия 2.1c,
производительность которой улучшена за счет применения аппаратного
умножения; для сравнения в колонке softmul C32 приведена
производительность C++ кода версии 1.2b.

64-разрядный код, как ассемблерный так и С++ скомпилирован под
Visual C++ 2010 Express с SDK 7.1 x64 в режиме Release.
Ассемблерный код протестирован для версии 2.0, С++ код - для
версии 2.1c с аппаратным умножением; для сравнения в колонке
softmul C64 приведена производительность C++ кода версии 2.0.

Библиотека NTL скомпилирована с отключенным макро NTL_STD_CXX.

Код для ARM скомпилирован под Pocket GCC 3.3.3 -O5 -DNDEBUG.


            Время выполнения операции в миллисекундах

                        Тест: Arif1 (+*)                       softmul
CPU                           asm32  asm64  NTL   C32   C64   C32   C64
-----------------------------------------------------------------------
ARM S3C2440A        (400 MHz)                                 130
ARM920T PXA312      (624 MHz)                                  80
Atom N270          (1600 MHz)     2           6     8          22
Pentium III/933     (933 MHz)     3          12     9          30
Pentium 4C/2400    (2400 MHz)     3           4     5          16
Athlon 900          (900 MHz)     2           8     7          28
Athlon XP 2500+    (1826 MHz)     1           4                14
Athlon 64 X2 3600+ (1900 MHz)     1     0     4     3     1    11     8
Athlon 64 X2 3800+ (2000 MHz)     1     0     3     3     1    10     8
Athlon 64 X2 4600+ (2400 MHz)     0           3                 9
Phenom II X3 710   (2600 MHz)     0     0     2                 8     6
Phenom II X6 1050T (2800 MHz)     0     0     2     1     0     7     5
Phenom II X6 1090T (2800 MHz)     0     0     2     2     0     6     5
FX-8150            (3600 MHz)     1     0     1     2     1     8     5
FX-8320            (3500 MHz)     0     0     1     2     0     8     5
Core Duo T2500     (2000 MHz)     2           4                13
Core 2 Duo E6420   (2130 MHz)     1           4                11
Core 2 Quad Q8200  (2330 MHz)     1     0     4     3     1    10     6
Core i7-950        (3200 MHz)     1     0     1     2     0     6     4
Core i7-6800K      (3600 MHz)     0     0     1     1     0     5     3
Xeon E3-1230       (3200 MHz)     1     0     1                 7     6
Xeon E3-1240v3     (3400 MHz)     0     0     1     1     0     5     3
                    Погрешность измерения ~1 ms

                        Тест: Arif2 (powmod)                   softmul
CPU                           asm32  asm64  NTL   C32   C64   C32   C64
-----------------------------------------------------------------------
ARM S3C2440A        (400 MHz)                               62000
ARM920T PXA312      (624 MHz)                               40000
Atom N270          (1600 MHz)  2235        1859  5516        5969
Pentium III/933     (933 MHz)  2906        3494  6750        8578
Pentium 4C/2400    (2400 MHz)  2343         906  3922        4297
Athlon 900          (900 MHz)  1892        2123  5477        8051
Athlon XP 2500+    (1826 MHz)   906        1047              4094
Athlon 64 X2 3600+ (1900 MHz)   890   562  1031  2512  1373  3406  1888
Athlon 64 X2 3800+ (2000 MHz)   813   500   969  2344  1297  3172  1797
Athlon 64 X2 4600+ (2400 MHz)   672         828              2640
Phenom II X3 710   (2600 MHz)   603   344   834              2380  1188
Phenom II X6 1050T (2800 MHz)   563   313   703  1610   750  2203  1094
Phenom II X6 1090T (2800 MHz)   484   266   610  1406   656  1922   953
FX-8150            (3600 MHz)   537   349   559  1571   765  2285  1152
FX-8320            (3500 MHz)   469   266   282  1656   765  2348  1078
Core Duo T2500     (2000 MHz)  1437         844              3765
Core 2 Duo E6420   (2130 MHz)  1234         735              2937
Core 2 Quad Q8200  (2330 MHz)  1125   578   656  1891   922  2688  1329
Core i7-950        (3200 MHz)   848   443   307  1210   581  1686   844
Core i7-6800K      (3600 MHz)   285   177   289  1026   499  1342   724
Xeon E3-1230       (3200 MHz)   561   374   453              1747   873
Xeon E3-1240v3     (3400 MHz)   313   187   297   984   479  1359   734
                    Погрешность измерения ~10 ms

                        Тест: Arif3 (*)                        softmul
CPU                           asm32  asm64  NTL   C32   C64   C32   C64
-----------------------------------------------------------------------
ARM S3C2440A        (400 MHz)                                2200
ARM920T PXA312      (624 MHz)                                1400
Atom N270          (1600 MHz)    33         109   130         366
Pentium III/933     (933 MHz)    55         214   158         494
Pentium 4C/2400    (2400 MHz)    45          64    77         245
Athlon 900          (900 MHz)    29         135   125         469
Athlon XP 2500+    (1826 MHz)    14          66               230
Athlon 64 X2 3600+ (1900 MHz)    12     3    61    56    14   189   133
Athlon 64 X2 3800+ (2000 MHz)    11     3    56    53    14   175   127
Athlon 64 X2 4600+ (2400 MHz)     9          48               147
Phenom II X3 710   (2600 MHz)     8     2    44               133    95
Phenom II X6 1050T (2800 MHz)     7     2    42    38     9   122    89
Phenom II X6 1090T (2800 MHz)     6     2    36    33     8   106    78
FX-8150            (3600 MHz)     7     3    27    37     9   137    91
FX-8320            (3500 MHz)     7     2    24    31     8   138    84
Core Duo T2500     (2000 MHz)    28          70               217
Core 2 Duo E6420   (2130 MHz)    23          70               175
Core 2 Quad Q8200  (2330 MHz)    21     8    64    42    11   161   105
Core i7-950        (3200 MHz)    17     6    21    27     7   104    67
Core i7-6800K      (3600 MHz)     6    2/1   15    19     5    87    57
Xeon E3-1230       (3200 MHz)    10     4    23               103    81
Xeon E3-1240v3     (3400 MHz)     7    2/1   16    19     5    92    58
                    Погрешность измерения ~1 ms

                        Тест: Arif4 (/)
CPU                           asm32  asm64   NTL  C32   C64
-----------------------------------------------------------
ARM S3C2440A        (400 MHz)                   17000
ARM920T PXA312      (624 MHz)                    9000
Atom N270          (1600 MHz)   570         561  1242
Pentium III/933     (933 MHz)   970        1056  2005
Pentium 4C/2400    (2400 MHz)   611         278   981
Athlon 900          (900 MHz)   543         705  1729
Athlon XP 2500+    (1826 MHz)   263         345   900
Athlon 64 X2 3600+ (1900 MHz)   264   153   305   758   374
Athlon 64 X2 3800+ (2000 MHz)   236   141   298   697   358
Athlon 64 X2 4600+ (2400 MHz)   195         256   581
Phenom II X3 710   (2600 MHz)   161    91   233   479   211
Phenom II X6 1050T (2800 MHz)   149    84   219   442   197
Phenom II X6 1090T (2800 MHz)   128    74   189   386   170
FX-8150            (3600 MHz)   126    90   146   478   205
FX-8320            (3500 MHz)   127    78    83   499   213
Core Duo T2500     (2000 MHz)   359         241   786
Core 2 Duo E6420   (2130 MHz)   313         205   606
Core 2 Quad Q8200  (2330 MHz)   286   149   186   553   242
Core i7-950        (3200 MHz)   218   121    89   347   155
Core i7-6800K      (3600 MHz)    70    48    88   262   126
Xeon E3-1230       (3200 MHz)   111    78    97   323   150
Xeon E3-1240v3     (3400 MHz)    75    47    92   264   133
                    Погрешность измерения ~10 ms

                        Тест: Arif5 (sqrt)
CPU                           asm32  asm64  NTL   C32   C64
-----------------------------------------------------------
ARM S3C2440A        (400 MHz)                   32000
ARM920T PXA312      (624 MHz)                   12000
Atom N270          (1600 MHz)  2922       23562  3125
Pentium III/933     (933 MHz)  2360       44453  4453
Pentium 4C/2400    (2400 MHz)  1531       11312  1891
Athlon 900          (900 MHz)  1312       27380  4376
Athlon XP 2500+    (1826 MHz)   656       13391  2141
Athlon 64 X2 3600+ (1900 MHz)   484   297 13088  1594   780
Athlon 64 X2 3800+ (2000 MHz)   453   234 12046  1469   750
Athlon 64 X2 4600+ (2400 MHz)   391       10031  1234
Phenom II X3 710   (2600 MHz)   364   203 10278  1140   563
Phenom II X6 1050T (2800 MHz)   344   172  9031  1063   531
Phenom II X6 1090T (2800 MHz)   297   156  7875   921   453
FX-8150            (3600 MHz)   396   321  5898  1094   512
FX-8320            (3500 MHz)   344   219  3474  1002   515
Core Duo T2500     (2000 MHz)  1062        9826  1844
Core 2 Duo E6420   (2130 MHz)  1141        8548  1422
Core 2 Quad Q8200  (2330 MHz)  1047   469  7767  1297   594
Core i7-950        (3200 MHz)   745   390  3658   960   408
Core i7-6800K      (3600 MHz)   331   162  3610   624   295
Xeon E3-1230       (3200 MHz)   530   328  3978   749   406
Xeon E3-1240v3     (3400 MHz)   344   162  3828   641   297
                    Погрешность измерения ~10 ms

ПРИМЕЧАНИЕ: Результаты программы Arifexp64x для Intel Haswell заметно
            улучшают только один показатель (ускорение ~25% в тесте
            Arif3, CPU Core i7-6800K и Xeon E3-1240v3, колонка asm64).

Скомпилированные тестовые программы доступны на странице:
http://www.imach.uran.ru/cbignum/arifrunr.htm

В отличие от тестовых программ, все программы для Windows в
дистрибутиве класса скомпилированы под Microsoft Visual C++ 2015
Community c ассемблерной оптимизацией. Применение более нового
транслятора не оказывает существенное влияние на результаты
тестов Arif1-5.

Ассемблерный пакет имеет ограниченную поддержку компиляторов
Linux из-за различий во встроенном ассемблере. К настоящему
времени он поддерживает аппаратное 32/64/128-разрядное умножение
и деление с применением ассемблерных инструкций MUL и DIV.


4.2.1. Оптимальная разрядность
------------------------------

В 32-разрядном режиме все операции могут проводится над числами
размером до 12,800,000,000 бит при условии наличия оперативной
памяти, достаточной для представления исходных данных, результата
и (для некоторых операций) их рабочих копий. Квадратный корень
лимитирован размером CBNL_MAX = 2,147,483,647 бит в 32-разрядном
режиме. Показатель сдвига должен быть в пределах -CBNL_MAX..CBNL_MAX.

Операции сложения, вычитания, умножения, возведения в степень,
сдвига, ввода-вывода, а также побитовые и логические операции
оптимизированы для любых максимальных размеров операндов.
Накладные расходы на умножение минимизированы для случая,
когда размер хотя бы одного из операндов не менее 500 бит.
Для оптимального выполнения остальных операций достаточно,
чтобы размер результата был не менее 200-500 бит.

Операции деления, модуля и возведения в степень по модулю
оптимизированы для однословных, двухсловных и многословных
делителей размером от ~500 до ~16,000,000 бит.

В 32-разрядном режиме наилучшие показатели обеспечиваются при
размере делителя до 1/32 размера кэш-памяти процессора; для кэша
рамером 512 Кбайт оптимальный размер делителя будет до ~120,000 бит.
Для процессоров с большим размером кэша оптимальный размер будет
пропроциональнго больше (например, для Intel Xeon с 8 Мбайт кэшем
он равен ~4,000,000 бит).

В 64-разрядном режимем наилучшие показатели обеспечиваются при
размере делителя до 1/64 кэш-памяти, т.е. до ~60,000 бит для кэша
размером 512 Кбайт.

Операция вычисления квадратного корня оптимизирована для операндов
размером до удвоенной кэш-памяти процессора.


4.2.2. Оценки производительности
--------------------------------

Оценки производительности даются для 32/64-разрядной ассемблерной
оптимизации при выполнении под процессорами AMD Phenom/Athlon/
Sempron, которые в рассматриваемой задаче обеспечивают более
высокую производительность, чем процессоры Intel Pentium и Core
прежних поколений.

ПРИМЕЧАНИЕ: Ассемблерный дополнительный пакет не включен
            в свободно распространяемую версию класса.

Оценки для 32-разрядного режима
-------------------------------

Операции сложения, вычитания, сдвига, а также побитовые и
логические операции требуют от 1/2 до 1/5 машинного такта на
получение каждого двоичного разряда результата, если размер
результата больше 200 бит. Оптимизированные операции += и -=
тратят на получение одного разряда около 1/15 машинного такта,
если размер результат больше 500 бит.

Число машинных тактов для умножения при разрядности хотя бы
одного числа от 1,000 бит может быть грубо оценено как
m * n / 200, где m и n - число битовых разрядов в числах,
округленное вверх до кратного 32. Расходы дополнительно снижаются
по методу Карацубы: если размер обоих чисел 1,600 бит или больше,
то оценка делится на 4/3 в степени log2 (n / 2000), где n - число
битовых разрядов в меньшем числе.

Число машинных тактов для деления чисел при разрядности делителя
от 2,000 бит до 1/32 размера кэш-памяти процессора может быть грубо
оценено как (m - n) * n / 30, где m и n - число битовых разрядов
соответственно в делимом и делителе.

Для вычисления квадратного корня аналогичная грубая оценка
составляет n * n / 120, где n - разрядность числа.

Оценка для ввода и преобразования строки составляет n * n / 400,
при разрядности числа до 100,000 бит. Для больших чисел оценка
делится на 4/3 в степени log2 (n / 20000).

Оценка для вывода и преобразования в строку составляет n * n / 75.

Оценки для 64-разрядного режима
-------------------------------

Операции сложения, вычитания, сдвига, а также побитовые и
логические операции требуют от 1/4 до 1/10 машинного такта на
получение каждого двоичного разряда результата, если размер
результата больше 400 бит. Оптимизированные операции += и -=
тратят на получение одного разряда около 1/25 машинного такта,
если размер результат больше 1000 бит.

Число машинных тактов для умножения при разрядности хотя бы
одного числа от 2,000 бит может быть грубо оценено как
m * n / 800, где m и n - число битовых разрядов в числах,
округленное вверх до кратного 32. Расходы дополнительно снижаются
по методу Карацубы: если размер обоих чисел 3,200 бит или больше,
то оценка делится на 4/3 в степени log2 (n / 4000), где n - число
битовых разрядов в меньшем числе.

Число машинных тактов для деления чисел при разрядности делителя
от 4,000 бит до 1/64 размера кэш-памяти процессора может быть грубо
оценено как (m - n) * n / 50, где m и n - число битовых разрядов
соответственно в делимом и делителе.

Для вычисления квадратного корня аналогичная грубая оценка
составляет n * n / 200, где n - разрядность числа.

Оценка для ввода и преобразования строки составляет n * n / 1200,
при разрядности числа до 200,000 бит. Для больших чисел оценка
делится на 4/3 в степени log2 (n / 40000).

Оценка для вывода и преобразования в строку составляет n * n / 125.

Прочие оценки
-------------

Число длинных операций для вычисления степени и степени по модулю
пропорционально размеру показателя в битах. Оценка для возведения
в степень по модулю равна n * m * m / 17 для 32-разрядного режима
и n * m * m / 28  для 64-разрядного режима, где n - число битовых
разрядов в показателе степени, m - число битовых разрядов в модуле.

ПРИМЕЧАНИЕ: Степень основана на длинных умножениях, а степень
            по модулю - на парах умножение-деление. Деление
            медленнее, поэтому оно определяет производительность
            операции в целом.

Алгоритм определения простого числа IsStrongPrime() доказывает
простоту чисел, меньших 341,550,071,728,321 за время меньше одной
миллисекунды. Для больших чисел выдает алгоритм выдает
вероятностный результат с достоверностью порядка 99,99999999%.
Время полной проверки пропорционально n в степени 3, где n - число
битовых разрядов в числе.

Более строгий алгоритм, IsMillerPrime() доказывает простоту чисел
любого размера при условии, что верна обобщенная гипотеза Римана.
Для близких по размеру чисел алгоритм работает примерно в 100 раз
медленнее, а для чисел большего размера время полной проверки растет
пропорционально n в степени 5, где n - число битовых разрядов в числе.


4.2.3. Технические особенности реализации
-----------------------------------------

При оптимизации программ следует учитывать следующие отличия
реализации неограниченных чисел от реализации встроенной арифметики
языка C++:

1.  При выполнении операций присваивания +=, -=, *=, /=, %=
    и т.п. обеспечивается более высокая производительность,
    (до 20% на коротких числах) чем при выполнении операций
    с конструированием временных объектов: +, -, *, /, % и т.п.
    По этой же причине префиксный инкремент и декремент
    работают быстрее, чем постфиксные варианты этих операций.

2.  Компилятор не проводит автоматическую оптимизацию операций
    с неограниченными числами и числовыми константами. В частности,
    не производится автоматическая замена сложения и вычитания 1
    на инкремент и декремент, а умножения и деления на степень
    двойки - на сдвиг. Тем не менее, умножение на степень двойки
    оптимизировано и выполняется так же быстро, как сдвиг влево -
    в отличие от деления на степень двойки, которое значительно
    медленнее сдвига вправо.

3.  Некоторые оптимизации можно отключить путем выключения следующих
    макро из Cbignumf.h:

    _CBIGNUM_HARDWARE_CBR   Использовать аппаратное сложение/
                            вычитание/сдвиг с переносом/займом.

    ПРИМЕЧАНИЕ: Операции с переносом применялись начиная с ранних
                версий класса и окончательно реализованы в версии 1.2.
                На современных процессорах Athlon/Core они примерно
                в 5 раз быстрее альтернативного С++ кода, но в отличие
                от него являются аппаратно зависимыми и реализованы не
                для всех компиляторов (см. раздел 1.1). Поэтому они
                включены в дополнительный ассемблерный пакет, а не в
                свободно распространяемую версию класса.

    _CBIGNUM_HARDWARE_MUL   Использовать аппаратное умножение с
                            результатом в виде двойного слова.

    ПРИМЕЧАНИЕ: Аппаратное умножение задействуется начиная с версии
                1.2a. На современных процессорах Athlon/Core оно может
                быть в десятки раз быстрее альтернативного битового
                умножения (в зависимости от применения в последнем
                аппаратных операций с переносом или заменяющего их
                С++ кода).

                Начиная с версии 2.1, аппаратное умножение доступно
                в свободно распространяемой версии класса для
                трансляторов Microsoft Visual C++ в 64-разрядном
                режиме, а начиная с версии 2.1c - для любых 32 и
                64-разрядных компиляторов. Но наиболее эффективная
                реализация по-прежнему находится в дополнительном
                ассемблерном пакете, где аппаратное умножение
                реализовано для распространенных 32 и 64-разрядных
                компиляторов (см. раздел 1.1).

    _CBIGNUM_HARDWARE_DIV   Использовать аппаратное деление.

    ПРИМЕЧАНИЕ: Аппаратное деление по умолчанию отключено в коде
                класса, за исключением преобразования неограниченных
                чисел в строку и факторизации однословных чисел в
                файле Prime.cpp при компиляции в 64-разрядном режиме.
                Причина заключается в ограниченном эффекте от его
                использования.

                Аппаратное деление может использоваться с версии 1.2c
                для деления и модуля чисел с одним значащим словом.
                Начиная с версии 2.1 оно может быть использовано для
                оптимизации возведения в степень под однословному модулю,
                начиная с версии 2.1a - для оптимизации деления/модуля
                неограниченного числа на однословный делитель. Наибольший,
                примерно трехкратный эффект достигается для двухсловных
                делимых и однословных делителей.

                Начиная с версии 2.1c все 64-разрядные тестовые программы
                компилируются с установленным макро _CBIGNUM_HARDWARE_DIV
                (это делается через опции транслятора, а не через код
                класса). 32-разрядные программы по-прежнему компилируются
                без макро _CBIGNUM_HARDWARE_DIV.

    _CBIGNUM_KARATSUBA_MUL  Использовать метод Карацубы, если оба
                            числа имеют размер 100 и более слов,
                            при аппаратном умножении 50 и более слов.

    ПРИМЕЧАНИЕ: Метод Карацубы реализован в версии 1.2a.
                Он относительно сложен относительно в кодировании
                и требовал долгого тестирования, которое было
                завершено в версии 1.2b public. Метод эффективен при
                операциях над числами большого размера, а иначе его
                можно отключить для увеличения надежности вычислений.

    _CBIGNUM_BLOCK_MUL      Использовать блочное умножение, если
                            оба числа имеют размер 715 и более слов.

    ПРИМЕЧАНИЕ: Блочный метод реализован в версии 1.0 для того,
                выполнять умножение в кэше L1 процессора. Теперь
                он заменяется более эффективным методом Карацубы,
                кроме случая, когда одно из чисел короче 100 слов
                при двоичном умножении и короче 50 слов при
                аппаратном умножении.

    _CBIGNUM_TERNARY_MUL    Использовать ускоренный на 30% троичный
                            метод умножения с таблицей сдвигов
                            вместо более простого двоичного.

    ПРИМЕЧАНИЕ: Троичный метод реализован в версии 1.2. Теперь
                двоичный и троичный методы заменяется более
                эффективным аппаратным умножением, если оно
                задействовано.

    _CBIGNUM_SHIFTTAB_MUL   Строить временные таблицы сдвигов
                            для ускорения умножения, если оба
                            числа имеют размер 3 и более слов.

    ПРИМЕЧАНИЕ: Таблицы сдвигов реализованы в версии 1.0.
                Теперь они заменяются более эффективным аппаратным
                умножением, если оно задействовано.

    _CBIGNUM_SHIFTTAB_DIV   Строить временную таблицу сдвигов
                            для ускорения деления и модуля,
                            если делитель как минимум на 3 слова
                            короче делимого, но не длиннее чем
                            примерно 512К слов в 32-разрядном
                            режиме и 256К слов в 64-разрядном
                            режиме.

    ПРИМЕЧАНИЕ: Деление с таблицей сдвигов реализовано в версии 1.0.

    _CBIGNUM_SMALL_DIV      Использовать специальные алгоритмы для
                            короткого делителя или модуля, состоящего
                            из одного или двух слов.

    ПРИМЕЧАНИЕ: Данные алгоритмы реализуются, начиная с версии 2.1.

    _CBIGNUM_SMALL_POWMOD   Использовать специальный алгоритм для
                            возведения в степень по короткому модулю,
                            состоящему из одного слова.

    ПРИМЕЧАНИЕ: Алгоритм реализован в версии 2.1.

    _CBIGNUM_REVERSE_MOD    Вычислять однословный модуль через обратное
                            умножение после аппаратного деления.

    ПРИМЕЧАНИЕ: Работает при установленном макро _CBIGNUM_HARDWARE_DIV.
                Отключено по умолчанию, поскольку оптимизация
                компилятора более эффективна.

    _CBIGNUM_REDUCE_JUMPS   Использовать дополнительные операции
                            для сокращения числа условных переходов.

    ПРИМЕЧАНИЕ: Было реализовано в версии 1.2c для деления чисел
                с одним значащим словом и по умолчанию отключено.
                С версии 2.1 игнорируется, поскольку оптимизация
                компилятора работает эффективнее.

4.  Комбинированные методы с таблицей сдвигов позволяют ускорить
    выполнение многократных операций с одним и тем же множимым
    или делителем, поскольку позволяют строить таблицу сдвигов
    только один раз. Кроме того, эти методы не проводят внутреннее
    копирование операндов в предположении, что операнды не
    перекрываются.

    Комбинированное умножение с таблицей сдвигов addmultab() и
    submultab() эффективно только в том случае, если недоступно
    быстрое аппаратное умножение. Оптимальный размер множимого
    в пределах в пределы от 500 битов до 6,000 битов; множимое
    может быть короче 500 битов, если оно длиннее множителя и
    множитель не короче 100 битов. Если размер операндов
    существенно выходит за указанные пределы, то целесообразнее
    использовать обычное умножение, т.к. его производительность
    будет выше благодаря применению блочных методов оптимизации.

    Комбинированное умножение addmulsmp() и submulsmp() эффективно
    и в том случае, если задействуется быстрое аппаратное умножение,
    прочие условия эффективности те же, что для умножения с
    таблицей сдвигов. Ускорение составляет несколько процентов
    за счет исключения внутренних операций копирования.

    Комбинированное деление м модуль с таблицей сдвигов эффективны
    при любых размерах делителя.

5.  В реализации умножения, деления, модуля, степени и возведения
    в степень по модулю предусмотрена эффективная встроенная
    оптимизация для однословных (машинных) чисел и для чисел,
    кратных большой степени двойки (~100 и выше).

6.  Передача неограниченного числа в функцию по ссылке проводится
    быстрее, чем передача по значению, т.к. в последнем
    случае производится копирование объекта. Если функция не
    модифицирует значение параметра, то передачу по значению
    рекомендуется заменить на передачу по константной ссылке:
        const cBigNumber&

7.  Создание и удаление локальных неограниченных чисел, определенных
    внутри функций и блоков, занимает примерно столько же
    времени, что и выполнение 2-3 коротких арифметических
    операций. Выносите локальные определения неограниченных чисел
    за пределы критических по времени циклов. Если не важна
    реентерабельноcть кода, то вместо этого можно добавить
    ключевое слово static и провести инициализацию в отдельном
    операторе присваивания:
        cBigNumber a = 1;            // Локальное определение
        static cBigNumber a; a = 1;  // Оптимизация

8.  Вывод очень длинного целого числа (> 100,000 цифр) в
    десятичном формате может занять много времени. Несколько
    быстрее (в 5 раз) вывод в шестнадцатеричном формате,
    но он тоже может быть очень медленным. Самая быстрая
    распечатка числа в шестнадцатеричном представлении
    выполняется методом dump().


4.2.4. Поддержка многопоточных приложений
-----------------------------------------

Полноценная поддержка многопоточности введена в версии 1.2c,
для чего в файле Cbignum.h установлено макро _CBIGNUM_MT.

Макро _CBIGNUM_MT исключает нереентерабельные статические методы
lastdivmod(), lastrootrm(). Замените их на реентерабельные операции
cBigDivMod(), cBigSqrtRm() или методы setdivmod(), setsqrtrm().
Также исключается нереентерабельный метод toatmp(), если только не
установлено макро _CBIGNUM_TOATMP, замените его на метод toa().

Начиная с версии 2.1b макро _CBIGNUM_MT запрещает использование
методов fit(), tab(), smp(), gc() и pack() с константными числами,
если только не установлено макро _CBIGNUM_CONSTCAST.

ПРИМЕЧАНИЕ: Если программа компилируется в режиме совместимости
            на трансляторе, не поддерживающем локальную память
            потока (см. раздел 3), то макро _CBIGNUM_MT замедляет
            бинарные операции, создающие временные объекты:
            +, -, *, /, % и т.п.

            Если Вам не требуется поддержка многопоточности, то
            можно уделить макро _CBIGNUM_MT, тогда будет включена
            более скоростная нереентерабельная реализация. Это
            особенно полезно при операциях над короткими числами,
            которые будут выполняться в 3 раза быстрее.
            Другое решение - использовать операции присваивания
            +=, -=, *=, /=, %= и т.п., производительность которых
            не зависит от макро _CBIGNUM_MT.


4.3. Расход памяти
------------------

С точки зрения расхода памяти, класс оптимизирован для чисел
размером свыше 500 бит в 32-разрядном режиме и свыше 1000 бит
в 64-разрядном режиме. В этом случае объем выделенной памяти
будет в среднем на 37.5% больше минимально необходимого.

Дополнительная оптимизация может быть достигнута при соблюдении
следующих правил:

1.  Для хранения коротких значений следует применять числа long
    или CBNL, которые во всех операциях можно свободно комбинировать
    с числами cBigNumber.

2.  Для своевременного удаления больших чисел размещайте их в
    локальных переменных. При использовании для этой цели глобальных
    и статических переменных следует учитывать, что по соображениям
    оптимизации в классе не предусмотрено автоматическое освобождение
    избыточной памяти, выделенной для хранения неограниченных чисел.

3.  Начиная с версии 2.0 класс не выделяет память для чисел в
    конструкторе по умолчанию, что позволяет экономить память,
    выделяемую под разреженные массивы (т.е. массивы, в которых
    большинство элементов равны 0). Чтобы эта экономия состоялась,
    не следует явным образом инициализировать элементы разреженных
    массивов 0, потому что явное присваивание любого, в том числе
    и нулевого значения приводит к выделению памяти, например:

    cBigNumber a [1000];                // Массив, заполненный 0.
    for (i = 0; i < 1000; i++) {        // Выделяется примерно 25
      a [i] = 0;                        // машинных слов для каждого
    }                                   // элемента массива.

    Эту оптимизацию можно отключить путем включения следующего
    макро из Cbignum.h:

    _CBIGNUM_DEF_ALLOC      выделять память в конструкторе по
                            умолчанию, как в версиях 1.x класса.

4.  Для освобождения избыточной памяти предусмотрен метод gc().

    * Метод gc() оптимизирован с точки зрения уменьшения фрагментации
      динамической памяти. Он оставляет зону расширения, составляющую
      в среднем 37.5% от размера числа, кроме небольших чисел, т.к.
      итоговый размер числа будет не меньше 104 байт в 32-разрядном
      режиме и не меньше 224 байт в 64-разрядном режиме. Исключением
      является нормализованный 0, который преобразуется в компактную
      форму из 0 слов с освобождением всей распределенной динамической
      памяти, если не установлено макро _CBIGNUM_DEF_ALLOC.

    * Метод gc() не проводит нормализацию числа.

5.  Максимальное освобождение памяти достигается при применении
    метода pack().

    * Метод pack() сокращает размер числа до минимума, определяемого
      исключительно разрядностью числа. Зона расширения при этом
      удаляется, а в динамической памяти остается только минимально
      необходимая служебная информация размером в два слова типа CBNL
      и собственно двоичный код числа. Исключением является
      нормализованный 0, который преобразуется в компактную
      форму из 0 слов с освобождением всей распределенной динамической
      памяти, если не установлено макро _CBIGNUM_DEF_ALLOC.

    * Метод pack() не проводит нормализацию числа.

    * Состояние упаковки не сохраняется при присваивании упакованного
      значения и передачи его в функцию по значению, т.к. эти операции
      выполняются путем копирования кода числа в новый объект.

    * Упакованная переменная автоматически распаковывается при
      выполнении модифицирующей операции, если требуется выделить
      дополнительную память.

    * При применении метода pack() возрастает фрагментация динамической
      памяти, что может привести к падению производительности.

6.  Для обнуления числа с освобождением динамической памяти можно
    использовать метод clear(), который аналогичен gc() после
    присваивания 0.


4.4. Взаимодействие с операционной системой
-------------------------------------------

Класс не ограничивает размерность чисел, для чего реализовано
автоматическое распределение памяти. В зависимости от размера
формируемых алгоритмом чисел, объем затребованной памяти может
привести к исчерпанию системных ресурсов и резкому замедлению
работы операционной системы. Поэтому в ответственных случаях
следует ограничивать максимальный объем оперативной памяти,
выделяемой программе.


4.5. Предупреждение ошибок
--------------------------

Внешний интерфейс класса построен в максимально точном соответствии
с соглашениями языка C++ (детали уточняются в разделе 5), поэтому
программистам следует обращать внимание в основном на соблюдение
общих правил безопасного программирования на языке C++:

1.  При применении операторов присваивания внутри выражений следует
    учитывать, что порядок выполнения выполнения операций не
    зафиксирован.

2.  При вводе чисел рекомендуется явным образом задавать основание
    системы счисления модификаторoм dec, oct или hex. Иначе основание
    будет определяться автоматический в зависимости от наличия 0
    перед числом.

3.  При применении оптимизированных методов следует соблюдать все
    оговоренные в их описании ограничения. В частности, некоторые
    оптимизированные методы не допускают, чтобы их операнды
    перекрывались.


4.6. Встроенные средства предупреждения ошибок
----------------------------------------------

Все методы класса включают в себя средства предупреждения внутренних
ошибок, которые по своему назначению делятся на два класса:

1.  Средства диагностики ошибок включаются при компиляции в отладочном
    режиме. Данные средства предназначены для выявления особых ситуаций,
    при которых увеличивается вероятность появления так называемых
    нерегулярных ошибок. В частности, отслеживаются ситуации выхода
    индекса за границу массива, нарушения внутренних инвариантов и т.п.
    При срабатывании средств диагностики выдается assert-сообщение и
    работа программы прекращается.

    ПРИМЕЧАНИЕ: При необходимости отключения контроля индексов на этапе
                отладки программы проведите компиляцию с макро NCHECKPTR.

                Кроме того, можно отключить контроль индексов только
                для входных (const) массивов путем компиляции с макро
                _CBIGNUM_NCHECKPTR.

2.  Средства коррекции ошибок включаются при компиляции программы
    в рабочем режиме с макро NDEBUG. Эти средства достаточно эффективны
    в том плане, что они нейтрализуют последствия ряда распространенных
    скрытых ошибок, в том числе некоторых ошибок переполнения буфера.

Благодаря наличию средств коррекции, активизация средств диагностики
на этапе отладки программы никоим образом не свидетельствует о том,
что в рабочем режиме методы класса будут работать неправильно. Тем не
менее, некоторая вероятность некорректной работы все таки существует,
поэтому обо всех случаях такого рода следует сообщить автору класса.

ПРИМЕЧАНИЕ: Средства предупреждения ошибок отлавливают до 70%
            всех внутренних ошибок, но некоторые ошибки все таки
            могут остаться незамеченными, в особенности если речь
            о вновь реализованных алгоритмах. Поэтому предусмотрена
            возможность отключить новые алгоритмы и использовать
            вместо них старые, лучше отлаженные версии кода.
            Возможности такого рода описаны в разделе 4.2.3.


5. Технические сведения
=======================

Данный раздел содержит технические сведения о текущей реализации
класса без предоставления гарантий относительно того, что все
сведения будут справедливы для последующих версий класса.


5.1. Сведения о реализации
--------------------------

В основу класса cBigNumber положен шаблон динамических массивов
Exarray.h, выполняющий распределение оперативной памяти.
В этом же файле находится шаблон ограниченных указателей exptr,
который применяется в файле Cbignumf.cpp для организации
контроля индексов на этапе отладки программы.

Для отключения контроля индексов следует задать макро NDEBUG или
NCHECKPTR. Макро NDEBUG задается по умолчанию при компиляции под
Visual C++ в режиме Release.

Контроль индексов, если он включен, замедляет работу методов
класса примерно на 150-400 процентов, но зато все некорректные
обращения к памяти отлавливаются так же надежно, как в Яве и С#.
При этом можно пользоваться безопасной арифметикой над указателями,
чего нет ни в Яве, ни даже в C#.


5.2. Особенности реализации штатных операций
--------------------------------------------

Операции над неограниченными числами проводятся по штатным
правилам языка С с использованием всех штатных операторов.
Особенности класса обусловлены ограничениями языка C++:

1.  Операция sizeof выдает размер дескриптора неограниченного
    числа (объекта cBigNumber), а не размер внутреннего
    представления числа в байтах.
    Размер внутреннего представления неограниченного числа
    в словах типа CBNL выдается методом length().
    Размер неограниченного числа в байтах равен произведению
    length() * sizeof (CBNL).

2.  Операция & выдает указатель дескриптора неограниченного
    числа (объекта cBigNumber), а не указатель внутреннего
    представления числа в памяти. Указатель внутреннего
    представления неограниченного числа в словах типа CBNL
    выдается методом base().

3.  При выполнении операций над неограниченными числами
    целочисленное переполнение не происходит.
    При нехватке оперативной памяти для представления
    неограниченного числа вызывается функция abort().

4.  Перед присваиванием беззнакового (unsigned) числа
    неограниченному числу или выполнением операции над ними
    беззнаковое число преобразуется к типу signed CBNL по
    правилам языка С, что может привести к интерпретации
    большого положительного числа, как отрицательного.

    Чтобы сохранить беззнаковое значение при присваивании,
    можно использовать метод code():
        cBigNumber a;                   // Неограниченное число.
        unsigned CBNL n = 0xFFFFFFFFUL; // Беззнаковое число,
        {                               // значение приведено как пример.
          a.expand (2);                 // Память под два слова.
          CBNL *pa = (CBNL*) a.code();  // Указатель для модификации кода.
          pa [0] = n;                   // Присвоение числа.
          pa [1] = 0;                   // Нулевое слово для знака.
          pa [-1] = 2;                  // Число слов.
          a.fit();                      // Нормализация.
        }                               // Удаление указателя.
    Вместо вызова метода fit(), в данном случае можно использовать
    присваивание:
          pa [-1] = 1 + ((CBNL)n < 0);  // Нормализованное число слов.

5.  Перед присваиванием числа с плавающей точкой неограниченному
    числу или выполнением операции над ними плавающее число
    преобразуется к типу signed CBNL по правилам языка С, т.е.
    путем отбрасывания дробных разрядов. Если полученное
    таким образом число не помещается в разрядную сетку CBNL,
    то результат преобразования не определен.

6.  В отличие от обычных чисел, для неограниченных чисел не
    предусмотрены операции приведения типа.
    Преобразование неограниченного числа к целому числу
    проводится явным образом с помощью метода loword(),
    результатом преобразования является число типа CBNL.
    Преобразование проводится с сохранением исходного
    значения числа при условии, что значение помещается
    в диапазон значений типа CBNL.
    Для проверки диапазона достаточно убедиться в том,
    что размер внутреннего представления неограниченного числа,
    выдаваемый методом length(), не больше равен 1:
      if (bignum.length() <= 1) num = bignum.loword();
      else ... /* ошибка */

    Для преобразования с поверкой диапазона можно применить
    методы toCBNL(), tolong(), toint() и toshort().

7.  Для исключения конфликта имен с библиотекой math.h
    функция возведения в степень названа cBigPow.

8.  Возведение в отрицательную степень интерпретируется,
    как возведение обратной величины (1/x) в положительную
    степень, при этом дробная часть обратной величины
    отбрасывается. Таким образом, результат будет следующим:
    ошибка деления для основания 0, 1 для основания 1 и
    0 для любого основания большего 1.

9.  Отрицательный показатель сдвига интерпретируется, как
    смена направления сдвига. В стандарте С результат такого
    сдвига не определен.

10. Квадратный корень отрицательного числа равен 0.

11. Начиная с версии 1.2 вывод отрицательных чисел с модификаторами
    hex и oct выполняется со знаком. Если требуется вывод без знака,
    то используйте функцию cBigUnsign() или проводите трансляцию с
    макро _CBIGNUM_UNSIGN_OCT_HEX.


Приложение 1: Пояснительная записка к работе на конкурс SofTool'99
==================================================================

                   Задача 1 (фирма Aladdin)

Написать класс C++ cBigNumber, позволяющий работать с целыми
числами произвольной длины. Реализовать перегруженные операторы
сложения, вычитания, умножения, целочисленного деления,
получения остатка от деления, возведения в степень.
Аргументами операторов могут быть объекты cBigNumber и
обычные целые числа (int).

Реализовать функцию ввода числа с клавиатуры и вывода на экран в
десятичном и шестнадцатеричном виде.

                   Пояснительная записка.

Задача сформулирована кратко, поэтому я направил в конкурсную
комиссию письмо с просьбой уточнить критерии оценки конкурсных
работ. Поскольку ответ не был получен, то был сделан вывод о
том, что все необходимые сведения содержатся в условиях задачи
в явном или неявном виде.

На основании условий задачи были cформулированы
и реализованы следующие требования:

1) Разрядность чисел и выбор алгоритмов умножения и деления.

Оптимальные алгоритмы умножения и деления существенным
образом зависят разрядности чисел; реализовать в
конкурсной работе все алгоритмы не представляется возможным.

Анализируя условия задачи, можно предположить,
что алгоритмы должны обеспечивать работу над числами любой
разрядности и при этом быть оптимальными:
 - для операций над длинным и коротким числом, т.к. эти
   операции особо оговариваются в задаче 1;
 - для операций над небольшими длинными числами
   (до 1000 бит), т.к. в задаче 2 речь идет о проверке
   простоты числа, что подразумевает небольшую разрядность.
Исходя их этого:
1. Числа представляются в дополнительном коде.
2. Для умножения и деления были выбраны
   "школьные" алгоритмы в двоичном варианте.
3. При реализации класса особое внимание уделялось снижению
   накладных расходов на вызов вычислительных методов.

Производительность класса при работе с числами, помещающимися
в пределах разрядной сетки long, составляет около 500 тысяч
арифметических операций в секунду на Pentium-166, что
примерно в 20 раз медленнее, чем встроенная арифметика.

При увеличении размера слагаемых, одного их множителей или
делимого производительность падает пропорционально размеру
чисел, при увеличении размера обоих множителей а также
делимого и делителя - пропорционально квадрату размера.

Алгоритмы тестировались на числах размером до 100,000 бит.

2) Переносимость.

Поскольку в условиях задачи не оговаривается аппаратно-
-программная платформа, а упомянут только компилятор
Visual C++, то это значит, что класс должен быть
переносимым по крайней мере между теми платформами,
для которых работают бравые парни из Microsoft
(Intel, Alpha, Strong ARM и т.п.).

Поэтому класс cBigNumber написан на стандартном C++
без применения машинно-зависимых ассемблерных
инструкций и нестандартных типов данных, таких,
как _int64. Надеюсь, что это решение создаст
хорошие предпосылки для переносимости класса.

3) Полнота реализации штатных операций языка С.

Программист, использующий класс cBigNumber,
должен иметь возможность использовать все штатные
операции языка C без каких-либо ограничений.


Приложение 2: Известные ошибки
==============================

1. Некоторые компиляторы отвергают оператор ?, если в альтернативах
   применяются различные операции, например: (a < 0? -a: a).

2. Класс не выполняет извлечение квадратных корней из чисел
   размером более CBNL_MAX бит и сдвига с показателем вне
   пределов -CBNL_MAX..CBNL_MAX бит (сообщается об ошибке
   "cBigNumber value out of range").

3. При присваивании числа C неограниченному числу или выполнении
   операции над ними число С подвергается предварительному
   преобразованию к типу long со знаком. Это преобразование не
   будет проведено корректно, если число относится к беззнаковому
   (unsigned) типу или типу с плавающей точкой и его абсолютное
   значение больше, чем CBNL_MAX.

4. По непонятной причине GNU g++ 2.9.6 строит странные программы с
   неверно работающими потоками cout и cerr, если глобальный
   cBigNumber инициализируется строковыми переменными, например,
        static const cBigNumber big_const ("2147483648", 10);

   Если Вам требуется писать переносимый код, то либо создавайте
   такие объекты локально в {} или инициализируйте их отдельно.

5. Компилятор C++ в Microsoft SDK 2003 R2 (64-bit) выдает массу
   предупреждений при работе с новой библиотекой iostream. Для
   завершения компиляции задействовать старую библиотеку по макро
   _CIOS_OLDSTREAM или выключить режим "treat warning as errors"
   (опция /WX-).

6. Начиная с версии 1.2c тестовые программы могут не компилироваться
   под 16-разрядным Borland C++ 3.1 из-за нехватки памяти. Чтобы
   использовать этот компилятор, следует установить макро NCHECKPTR
   и/или отключить избыточные блоки кода в файле Cbignumf.h.


Приложение 3: Что нового
========================

15.09.1999 - работа на конкурс SofTool'99

- Реализован базовый набор арифметических операций над длинными числами.


08.10.1999 - класс размещен в Интернет.

- Отлажены методы определения простоты числа.

- Реализован ускоренный вывод больших чисел по методу двоичного дерева,

- Реализована ускоренная операция деления с применением таблицы сдвигов.


25.10.1999

- Разрешены возведение в степень и сдвиг с отрицательным показателем.

- Разрешено возведение в степень по отрицательному модулю.

- Операция деления ускорена в 2-3 раза за счет применения встроенного
  ассемблера x386 (опция). Компиляция ассемблерных инструкций
  обеспечивается в Borland C++ 4.5.

- Реализован прогресс-индикатор при выводе больших чисел (100 тыс. бит).

- ИСПРАВЛЕНО: Проблемы при компиляции в Borland C++ Builder 1.0 и
              Visual C++ 5.0, появившиеся в предыдущей версии класса.


31.10.1999

- ИСПРАВЛЕНО: Ошибка распределения памяти в методе addmul().

- Обеспечена компиляция ассемблерных инструкций в отладочном режиме.

- Отладочный контроль индексов теперь включен по умолчанию; для
  его отключения следует установить макро NDEBUG или NCHECKPTR.


12.04.2000

- Поддержка Visual C++ 6.0, кроме ассемблерных инструкций.

- Максимальный размер 32-разрядного динамического массива уменьшен
  в два раза - c 4Г до 2Г. Это потребовалось для того, чтобы обойти
  ошибку в Visual C++ 6.0: если не установлен SP3, то в режиме
  оптимизации по скорости транслятор вычисляет константные выражения
  типа (SIZE_T_MAX-4)/4 по правилам знаковой арифметики.
  Изменения затронули функции exmuladd и exmul в файле Exarray.h.
  В 16-разрядном режиме максимальный размер массива по-прежнему 64К.

- Вместо константы SIZE_T_MAX теперь применяется константа EXSIZE_T_MAX,
  задающая максимальное значение результата целочисленных вычислений
  с контролем переполнения разрядной сетки.


17.05.2000

- Новая версия шаблона Exarray.h.

- Вместо метода ptr(), исключенного из шаблона exarray,
  теперь применяется макро EXPTRTYPE.

- Макрофункции заменены на inline - функции.


05.09.2001

- Методы tolong(), toint() и toshort() для формирования
  целого числа с проверкой диапазона.


14.03.2003 - Версия 1.0 beta public

- Написана программа Arifexp и командный файл Arifrand.bat для
  тестирования методов класса на случайных примерах.

- Проведено тестирование класса на 20,000,000+ случайных примерах.

- Добавлены методы вычисления квадратного корня.

- Операции умножения и умножения с накоплением ускорены в 3-4 раза
  за счет применения таблицы сдвигов, блочного метода и (опция)
  встроенного ассемблера x386. Компиляция ассемблерных инструкций
  обеспечивается в Borland C++ 4.5.

- Новый метод addmultab() для умножения с накоплением и предварительно
  подготовленной таблицей сдвигов.

- Определены требования к памяти при делении очень больших
  чисел (до 64 Mбайт).

- Ввод больших чисел ускорен в 5 раз по методу двоичного дерева.

- Прогресс - индикатор при вводе больших чисел.

- В методе addmultab() появилась опция для указания сдвига
  на заданное число слов.

- Оптимизированные операции сдвига для Intel x386 при
  умножении, делении и вычислении квадратного корня.

- Новые методы деления с остатком setdivmod() и setdivmodtab(),
  не задействующие служебный буфер cBigNumber::lastdivmod().

- При выводе и преобразовании в строку сохраняется значение
  служебного буфера cBigNumber::lastdivmod().

- Методы gc() и pack() для освобождения памяти.

- Метод set() теперь подразумевает десятичное число по умолчанию.

- Удален метод compl(), имя которого зарезервировано в стандарте C++.

- Устраненo избыточное копирование в операторе /=.

- Сокращен перебор делителей в методе HasFactor().

- ИСПРАВЛЕНО: Две ошибки при делении отрицательного числа.

- ИСПРАВЛЕНО: Ошибка при делении, из-за которой могло быть
              получено частное с неверным знаком.

- ИСПРАВЛЕНО: Математическая ошибка при возведении в степень по
              модулю. Раньше результаты были корректными только
              в том случае, если показатель степени был меньше
              модуля.

- ИСПРАВЛЕНО: Ошибки удаления завершающего символа из потока ввода
              и возвращения метки конца файла в поток ввода.

- ИСПРАВЛЕНО: Фатальная ошибка распределения памяти при возведении
              в степень 0.

- ИСПРАВЛЕНО: Ошибка распределения памяти в методе powmod().

- ИСПРАВЛЕНО: Ошибки распределения памяти в отладочных режимах
              addmul(), tab(), оператора вывода, умножения и деления.

- ИСПРАВЛЕНО: Ошибка в отладочном режиме метода addmultab()
              и соответствующая ей некорректность в документации.

- ИСПРАВЛЕНО: Незначительные несоответствия при распределении
              памяти в методах pow(), powmod(), setshl().

- Реализован режим экономии памяти для 16-разрядных компиляторов.

- Реализовано автоматическое снижение приоритета при работе
  тестовых программ под Windows и обработка ошибок вывода.

- Обеспечена компиляция в GNU g++ 2.9.6, кроме ассемблерных инструкций.

- В дистрибутив включены тестовые программы для Linux.

- Уточнено лицензионное соглашение и дополнена документация.

- Подготовлен перевод документации на английский язык.

- Вся документация теперь размещается в одном файле.


31.03.2003 - Обновление версии 1.0 beta public

- Совместимость с Borland C++ Builder 6.0.


05.07.2003 - Версия 1.1 beta public

- Совместимость с Visual C++ 7.0.

- Комментарии к исходным кодам переведены на английский.

- Изменения в шаблоне Exarray.h.


12.09.2005 - Версия 1.1a beta public

- ИСПРАВЛЕНО: Знак результата возведения в степень по модулю теперь
              не зависит от знака модуля.
  ВНИМАНИЕ:   Проверьте, что ваши программы на зависят от этой ошибки
              в спецификации!

- ИСПРАВЛЕНО: Операция возведения в степень по модулю теперь
              корректно работает для отрицательной базы.

- ИСПРАВЛЕНО: Ошибка распределения памяти при возведении в степень
              по отрицательному модулю со старшим словом 0x80000000.

- ИСПРАВЛЕНО: Ошибка распределения памяти при возведении в степень
              по модулю 0, если разрешено деление на 0.

- ИСПРАВЛЕНО: Ошибка распределения памяти в отладочном режиме при
              умножении двух длинных (больше 480 слов) отрицательных
              чисел со старшими словами 0x80000000.

- ИСПРАВЛЕНО: Ошибка assert в отладочном режиме setdivtab(),
              setmodtab(), setdivmodtab() при делении отрицательного
              числа на 0.

- ИСПРАВЛЕНО: Операции сдвига переписывают cBigNumber::lastdivmod()
              если количество бит задано неограниченным числом.

- ИСПРАВЛЕНО: Ошибка переполнения разрядной сетки при извлечении
              квадратного корня из чисел размером более INT_MAX бит.

- ИСПРАВЛЕНО: Описание аргумента n в методе addmultab (a,b,n).

- Исправления в разделе 1.2 и дополнения в разделе 4.2.3
  документации.

- Пополнен список ошибок в Приложении 2, включая проблему с
  реентерабельностью.


28.09.2005 - Исправление версии 1.1a beta public

- ИСПРАВЛЕНО: Возведение в степень по модулю выдает 1, если старшее
              слово модуля равно 0 (спасибо Александру).

- Примеры команд для компиляции под Linux в разделе 3.


31.10.2005 - Обновление документации

- Подробнее описаны особенности выполнения операций над
  беззнаковыми числами и числами с плавающей точкой.

- Документирован метод expand() для распределения памяти.

- Более подробное описание метода code().


12.11.2005 - Обновление версии 1.1a beta public

- Ассемблерный код теперь распространяется в дополнительном пакете.

- Тестовые программы собраны под компилятором Visual C++ 6.0
  с ассемблерной оптимизацией.

- Тесты производительности для различных процессоров в разделе 4.2.

- Новые оценки производительности в разделе 4.2.2.

- ИСПРАВЛЕНО: Метод setneg() не обращает знак числа LONG_MIN.

- ИСПРАВЛЕНО: Ошибка распределения памяти в шаблоне Exarray.h.


26.11.2005 - Обновление версии 1.1a beta public

- Файлы Random.h and Random.c переименованы в Random3.h и Random3.c.

- ИСПРАВЛЕНО: Неправильная таблица факторизации в Prime.cpp (спасибо
              Nicolas).

- ИСПРАВЛЕНО: Метод b_SPRP() возвращает "возможно, простое" на четных
              числах (Nicolas).


05.09.2006 - Версия 1.2 beta internal

- Обеспечена совместимость с Visual C++ Express 2005 и другими
  трансляторами, не поддерживающими старую библиотеку iostream.h.

- Подключение библиотеки iostream теперь необходимо только для
  операторов ввода-вывода в соответствующие потоки. В частности,
  функции преобразования числа в строку и строки в число теперь
  могут применяться без подключения библиотеки iostream.

- Увеличена скорость умножения (50%) для чисел из 3 и более слов.

- Оптимизированы операции накопления += и -=. В дополнение к более
  эффективному коду C, на них также распространяется ассемблерная
  оптимизация.

- Более гибкие методы проверки на простоту с оптимизированным
  алгоритмом. SPRP() и факторизация работают примерно в 2 раза
  быстрее для модулей > 7919.

- ИЗМЕНЕНИЕ: Функция HasFactor() переименована в TestFactor().
             Чтобы вернуть имя, определите макро _CBIGNUM_HASFACTOR.

- ИЗМЕНЕНИЕ: Ненулевые коды возврата функций SPRP() и IsPrime().

- ИЗМЕНЕНИЕ: Для использования операторов потокового ввода-вывода
             надо подключить новый файл Cbignums.h. Файл Cbignums.h
             теперь не подключает библиотеку iostream.

- ИЗМЕНЕНИЕ: Вывод отрицательных чисел с модификаторами hex и oct
             теперь выполняется со знаком. Если требуется вывод без
             знака, то используйте функцию cBigUnsign() или проводите
             трансляцию с макро _CBIGNUM_UNSIGN_OCT_HEX.

- ИЗМЕНЕНИЕ: Методы и функции класса осуществляют вывод на консоль
             через специальные потоки cTTY, см. раздел 3.2.
             По умолчанию вывод отключен.

- ИЗМЕНЕНИЕ: Статические методы lastdivmod() и lastrootrm() подлежат
             исключению в версии класса 2.0. Используйте вместо
             них методы setdivmod() и setsqrtrm().

- ИЗМЕНЕНИЕ: Метод erange() выводит короткий дамп числа вместо полного.

- ИЗМЕНЕНИЕ: Метод bits() теперь возвращает значение long вместо int,
             при переполнении вызывает erange().

- Новые методы setbits(), exbits(), setexbits(), words(), exwords().

- Новые конструкторы и методы cBigAbs(), abs(), setabs(),
  cBigUnsign(), unsign(), setunsign().

- Генератор случайных чисел: конструктор cBigRandom(), метод setrandom(),
  long-функции в Random3.h и Random3.cpp.

- Новые методы submul(), submultab().

- Методы setdivtab(), setmodtab(), setdivmodtab() теперь не требуют,
  чтобы делимое было нормализованным.

- Оптимизировано умножение длинных чисел (более 480 слов) на
  короткие числа (1 или 2 слова).

- Небольшая оптимизация деления для очень длинных чисел.

- Разрешено возведение в степень чисел размером более INT_MAX бит.

- ИСПРАВЛЕНО: Реализация метода dump() зависит от разрядности процессора.

- ИСПРАВЛЕНО: Ошибки при работе с ненормализованными нулями.

- ИСПРАВЛЕНО: Маловероятные ошибки при диагностике нехватки ресурсов
              для выполнения левых сдвигов и возведения в степень.

- Новая версия программы Arifexp:
    Ключи -div0, -size, -v, -rep n, -rand 0, -rand all.
    Добавлены операции ++a, --a, a-b*c, удалены операции a+b\c, a*b%c.
    Суффикс R для подстановки случайного числа с заданным числом бит.
    Ключ -check теперь проверяет результат всех операций,
    кроме степени с показателем, отличным от 2,4,8.

- Дополнительные тесты в Arifrand.bat.

- Тест генератора случайных чисел Arifr.bat.


29.11.2006 - Версия 1.2 beta public

- Функции для проверки на простоту теперь имеют дополнительный
  выходной параметр для последнего протестированного делителя или
  основания SPRP. Если число доказано, как составное, то там будет
  делитель или не прошедшее проверку основание SPRP.

- ИЗМЕНЕНИЕ: Переименована пара функций из internal версии:
             FastExactSPRP() в FastSPRP(), PostExactSPRP() в PostSPRP().

- Опции для выбора алгоритма в программе Miller.

- Расширенное тестирование программы Miller на 1,000,000,000+ примерах.

- ИСПРАВЛЕНО: Программа сваливается после компиляции в режиме Release
              под трансляторами Microsoft Visual C++ .NET, SDK 2003 и 2005
              с опцией /Ob2 (auto inline).


30.04.2007 - Версия 1.2a beta internal

- Быстрое умножение больших чисел по методу Карацубы, увеличивающее
  производительность при размере обоих операндов от 6,000 битов.

  ПРИМЕЧАНИЕ: Метод Карацубы относительно сложен в реализации
              и тестировании. Он введен в версию 1.2а класса
              как часть программы бета-тестирования. Если Вам
              нужны надежные вычислению, то его лучше отключить,
              для чего надо удалить из файла Cbignumf.inl макро
              _CBIGNUM_KARATSUBA_MUL.

- В связи с реализаций метода Карацубы, рекомендованный верхний предел
  для применения методов addmultab() and submultab() составляет теперь
  6,000 бит.

- Ограниченная экспериментальная поддержка многопоточных приложений
  с макро _CBIGNUM_MT.

- Новые операции cBigDivMod() и cBigSqrtRm().

- Новые машинно-зависимые методы set() и setr().

- ИСПРАВЛЕНО: Переполнение стека при сдвиге с отрицательным показателем
              LONG_MIN.

- ИСПРАВЛЕНО: Операции возведения в степень и степень по модулю
              переписывают cBigNumber::lastdivmod(), если показатель
              степень меньше 0.

- ИСПРАВЛЕНО: Опечатка во введении на английском к внутренним функциям
              cBigNumberMAddM(), cBigNumberMSubM(), _cBigNumberMSubD()
              (ошибка не затрагивает код).

- Для ввода-вывода по умолчанию используется стандартная библиотека
  iostream, если задействованы трансляторы Microsoft Visual C++ .NET,
  GNU g++ 3.x, 4.x и выше.

- Обеспечена компиляция в GNU g++ 4.1, кроме ассемблерных инструкций.

- Тест возведения в степень по модулю Arif2.bat.

- 32-битный ассемблер для Visual C++ и Borland C++ Builder
  (дополнительный пакет).


22.09.2007 - Версия 1.2a beta public

- Аппаратное умножение с применением ассемблерной инструкции MUL
  (в дополнительном пакете), выполняется в 10 раз быстрее.

  ПРИМЕЧАНИЕ: Ассемблерный дополнительный пакет не включен
              в свободно распространяемую версию класса.

- Две реализации метода Карацубы, оптимизированные соответственно
  для свободно распространяемого С кода и дополнительного
  ассемблерного пакета.

  ПРИМЕЧАНИЕ: Метод Карацубы относительно сложен в реализации
              и тестировании. Он введен в версию 1.2а класса
              как часть программы бета-тестирования. Если Вам
              нужны надежные вычислению, то его лучше отключить,
              для чего надо удалить из файла Cbignumf.inl макро
              _CBIGNUM_KARATSUBA_MUL.

- Быстрое копирование в отладочном режиме, если применяется
  дополнительный пакет.

- Дополнительное алгоритмические ускорение ввода чисел.

- Сравнение производительности с библиотекой NTL.

- ИСПРАВЛЕНО: Умножение отрицательного и положительного числа может
              дать некорректный результат в версии 1.2a beta internal.

- ИСПРАВЛЕНО: Макро _CBIGNUM_BLOCK_MUL может привести к переполнению
              буфера в версии 1.2a beta internal.

- ИСПРАВЛЕНО: Оператор вывода << может игнорировать флаги
              ios::uppercase и ios::showbase (Nicolas).

- ИСПРАВЛЕНО: Игнорируется модификатор width() потока вывода.

- ИСПРАВЛЕНО: Внутренняя функция cBigNumberCopyShr() не работает
              для ненормализованного 0.

- ИСПРАВЛЕНО: Увеличен размер буфера для внутренних функций
              cBigNumberPow(), cBigNumberPowMod().

- ИСПРАВЛЕНО: Размер буфера в спецификации к внутренним функциям
              cBigNumberMAddMulShl(), cBigNumberMSubMulShl(),
              cBigNumberMAddMulShlKar(), cBigNumberMSubMulShlKar()
              (ошибка не затрагивает код).

- ИСПРАВЛЕНО: Опция -size программы Arifexp и метод dump()
              работают неправильно под Visual C++ .NET.

- ИСПРАВЛЕНО: Программа Arifexp не проверяет остаток во время
              обратного теста умножения.

- Дополнения в Arifexp:
  - Выводится среднее время под опцией -rep.
  - Более эффективный тест умножения под опцией -check.
  - Опция -time.

- Проверена совместимость с Microsoft Visual C++ Express 2008.


12.06.2009 - Версия 1.2b beta public

- Реентерабельный метод toa() вместо подлежащего исключению toatmp().

- Операции cBigBits() и cBigExBits().

- Новые файлы Cbignumf.h and Cbnl.h обеспечивают зависимую от
  компилятора информацию для более аккуратной оценки времени
  выполнения в программе Arifexp.

- Программа Arifexp проверяет корректность преобразования числа в строку
  если задана опция -check.

- Оператор сравнения ? в программе Arifexp и тест сравнения в Arifrand.bat.

- ИСПРАВЛЕНО: Программа Arifexp не выдает код ошибки на неверных выражениях.

- ИСПРАВЛЕНО: Оценка времени умножения в программе Arifexp.

- ИСПРАВЛЕНО: Оценка времени деления в программе Arifexp и документации.

- ИСПРАВЛЕНО: Оценки времени выполнения в программе Arifexp под Linux.


28.07.2009 - Версия 1.2b public

- Оптимизация блочного умножения в дополнительном ассемблерном пакете,
  когда неприменим метод Карацубы (до 5% увеличения производительности,
  если один операнд меньше 50 long слов, а второй операнд в 10
  и более раз больше).

- Новые методы addmulsmp() и submulsmp() используют аппаратное умножение,
  если оно задействовано, вместо таблицы сдвигов. Методы addmultab()
  и submultab() всегда используют таблицу сдвигов.

- Новый метод smp() строит таблицу сдвигов, если аппаратное умножение
  не задействовано.

- Новая версия шаблона Exarray.h для работы в 64-разрядном режиме.

- Генератор Random3 приспособлен для работы в 64-разрядном режиме.

- Обеспечена совместимость с GNU g++ 4.1.2 в 64-разрядном режиме.

- Обеспечена совместимость с GNU g++ 4.2.3.

- Gettimer.c поддерживает DPMI в Borland C++ 4.5.

- Gettimer.c использует операции long вместо double, где это возможно.

- ИСПРАВЛЕНО: Программа Arifexp неверно выполняет ++ и -- под ключом -v.

- ИСПРАВЛЕНО: Программы не возвращают код 255.

- Командный файл Millrand.bat для тестирования на простоту.

- 32-разрядные исполняемые файлы для Pocket PC в дополнительном пакете.

- 64-разрядные исполняемые файлы для Linux и тестовые файлы .sh.

- Производительность в 64-разрядном режиме под Linux в разделе 4.2.

- Производительность под ARM Pocket PC в разделе 4.2.

- ИСПРАВЛЕНО: Производительность в ассемблерном режиме для процессоров
              Pentium III/933 и Pentium 4C/2400 по тестам Arif1-3
              в разделе 4.2.

- Проведено сокращенное тестирование в 64-разрядном режиме.

- Бета-тестирование завершено.


27.08.2009 - Обновление документации к версии 1.2b public

- Тесты производительности для ARM, Intel Atom и AMD Phenom.


19.11.2009 - Дополнения к версии 1.2b public

- Тест голосования при умножении с помощью addmultab()/submultab() в
  программе Arifexp.

- Быстрая факторизация 64-разрядных чисел с применением 64-разрядного
  машинного деления в Prime.cpp, актуальная для 64-разрядного g++.

- Программа Miller64 для быстрой факторизации 64-разрядных чисел
  под 64-разрядным Linux.


15.12.2009 - Версия 1.2c beta internal

- Класс получил реентерабельный код с поддержкой многопоточности.

- ИЗМЕНЕНИЕ: Макро _CBIGNUM_MT включено по умолчанию.

- ИЗМЕНЕНИЕ: Исключены нереентерабельные статические методы
             lastdivmod(), lastrootrm(), кроме случая отключения
             макро _CBIGNUM_MT. Замените их на реентерабельные
             операции cBigDivMod(), cBigSqrtRm() или методы
             setdivmod(), setsqrtrm().

- ИЗМЕНЕНИЕ: Исключен нереентерабельный метод toatmp(), если
             только не отключено макро _CBIGNUM_MT или установлено
             макро _CBIGNUM_TOATMP. Замените его на метод toa().

- Преобразование строка-число и вычисление квадратного корня
  оптимизированы для макро _CBIGNUM_MT.

- Умножение, деление, модуль, степень и возведение в степень по модулю
  оптимизированы для чисел, кратных большой степени двойки (~100 и выше)
  под макро _CBIGNUM_MT.

- Возведение в степень по модулю оптимизировано для модуля, кратного
  большой степени двойки (~100 и выше).

- Специальный код для ~10-кратного ускорения деления и модуля чисел
  с одним значащим словом.

- В несколько раз ускорено выполнение методов bits() и exbits().


10.01.2010 - Обновление версии 1.2c beta internal

- Заголовочный файл Cthr.h для поддержки многопоточности в приложениях.

- ИСПРАВЛЕНО: Гонки в классе cBigTemp при многопоточном режиме (но
              класс стал работать медленнее - это будет поправлено в
              версии beta public).

- ИСПРАВЛЕНО: Неправильная реализация метода set(a,n) для типа long.


28.07.2010 - Версия 1.2c beta pubic

- Реализована поддержка локальной памяти потока в классе cBigTemp,
  что сделало версию 1.2c в многопоточном режиме такой же быстрой,
  как предыдущую версию 1.2b в однопоточном режиме. См. описание
  макро EXTHREAD_LOCAL в разделе 3.

- Заголовочный файл Exthread.h автоматически определяет макро
  EXTHREAD_LOCAL для трансляторов Borland/Microsoft и GNU g++.

- Добавлена опция -par n в программу Arifexp для организации вывода
  данных в параллельном потоке под Windows.

- Программа Arifexp теперь не выводит результат проверки, если она
  совпадает с исходными данными.

- Работа командного файла Arifrand.bat ускорена в 2-3 раза за счет вывода
  данных в параллельном потоке и отказа от вывода проверочных данных.

- ИСПРАВЛЕНО: Гонки в методах ввода-вывода в многопоточном режиме.


27.09.2010 - Обновление версии 1.2b public

- ИСПРАВЛЕНО: Некорректная реализация cBigAbs() и setabs().

- ИСПРАВЛЕНО: Некорректная реализация cBigExBits() и setexbits(),
              неправильный пример в описании cBigExBits().


28.09.2010 - Обновление версии 1.2c beta pubic

- Тест производительности для Intel Core i7.

- Программа Arifexp и тестовый файл Arifrand.bat выполняют операции
  ~, @(abs), U(unsign), M(bits), U(exbits).

- Усовершенствован метод оценки времени в программе Arifexp.

- ИСПРАВЛЕНО: Некорректная реализация cBigAbs() и setabs().

- ИСПРАВЛЕНО: Некорректная реализация cBigExBits() и setexbits(),
              неправильный пример в описании cBigExBits().

- ИСПРАВЛЕНО: Ошибка распределения памяти в методах преобразования
              числа в строку и строки в число.

- ИСПРАВЛЕНО: Неверный результат cBigCompl() и setcompl()
              для числа из 0 слов.

- ИСПРАВЛЕНО: Неверный результат +, -, ^, &, | для числа из 0 слов
              и машинного числа.

- ИСПРАВЛЕНО: Метод loword() может выдать неверный результат для
              числа из 0 слов.

- ИСПРАВЛЕНО: Порча памяти методами tab() и smp() для числа из 0 слов.

- ИСПРАВЛЕНО: Ошибка assert в отладочном режиме при возведении
              в степень по модулю базы из 0 слов.

- ИСПРАВЛЕНО: Оценка времени сложения и вычитания в программе Arifexp.

- Обновлена оценка времени деления.


01.10.2010 - Версия 2.0 beta internal

- ИЗМЕНЕНИЕ: Вместо типа long применяется тип CBNL, определенный в
             Cbnl.h для обработки 64-разрядных чисел под Visual C++
             в 64-разрядом режиме.

- ИЗМЕНЕНИЕ: Методы code(), loword(), hiword(), bits(), exbits()
             теперь выдают значение типа CBNL, которое в зависимости
             от транслятора может быть long, __int64, __int128 и т.д.

- ИЗМЕНЕНИЕ: Число со значением 0 может состоять из 0 слов.

- Все конструкторы, операции присваивания и метод set() не выделяют
  память для числа 0, если память не была распределена ранее
  (память выделяется при присваивании ненулевого значения или при
  выполнении модифицирующей операции, даже если ее результат 0).

- Методы gc() и pack() освобождают всю память, выделенную под число 0.

- 64-битный ассемблер для Visual C++ (в дополнительном пакете),
  ускорение в 3-40 раз для процессоров AMD.

- Файлы для определения компилятора Cbnl.inl and Cbnl64.inl
  (в дополнительном пакете).

- Программы Arifexp64, Matrix64, Miller64 для 64-разрядной
  Windows.

- Файлы .bat вызывают 64-разрядные программы под 64-разрядной Windows.

- Новый метод преобразования toCBNL().

- Документирован метод clear(), обеспечена его корректная работа.

- Тесты и оценки производительности для 64-разрядного режима в
  разделе 4.2, в том числе для Intel Core i7 и AMD Phenom.


20.11.2010 - Обновление версии 2.0 beta internal

- Соглашение fastcall для вызова критических функций в 32-разрядном
  режиме Visual C++ как опция компиляции в Cbnl.h.
  По умолчанию отключено, т.к. неэффективно.

- Альтернативный 32-разрядный ассемблерный код для Visual C++ с
  соглашением о связи fastcall как опция компиляции в Cbnl.h.
  По умолчанию отключен, т.к. неэффективен.

- Удалены лишние операции из 64-разрядного ассемблерного кода.

- Документированы макро _CBIGNUM_DEF_ALLOC и _CBIGNUM_NCHECKPTR.

- Поправлены разделы 1.1, 1.2 и 4.3 документации.


22.11.2010 - Дополнения к версии 2.0 beta internal

- Аппаратное умножение с применением ассемблерной инструкции MUL для
  GNU g++ (в дополнительном пакете), выполняется в 8 раз быстрее.

- Исполняемые файлы для Linux с ускоренным 32/64-разрядным
  аппаратным умножением.


30.03.2011 - Версия 1.2c pubic

- Документирован метод clear(), обеспечена его корректная работа.

- Поправлены разделы 1.1, 1.2 и 4.3 документации.

- Бета-тестирование завершено.


30.03.2011 - Версия 2.0 beta pubic

- Внутреннее тестирование завершено.


05.03.2013 - Версия 2.0 pubic

- Тест производительности для AMD FX.

- Бета-тестирование завершено.


12.03.2013 - Обновление документации к версии 2.0 pubic

- Убрано ограничение реентерабельности из списка ошибок.

- Сведения о разреженных массивах в разделе 4.3.


05.05.2013 - Обновление документации к версии 2.0 pubic

- Тест производительности для Intel Xeon E3-1230.


16.01.2015 - Обновление документации к версии 2.0 pubic

- Тест производительности для Intel Xeon E3-1240v3.

- Тест производительности для Intel Core 2 Quad Q8200.


29.07.2016 - Версия 2.0a pubic

- Совместимость с Microsoft Visual C++ 2015.

- Ассемблерное умножение на Intel Haswell ускорено на 25% за
  счет применения инструкции MULX.

- Программы Arifexp64x, Matrix64x и Miller64x для 64-разрядной
  Windows и процессоров с набором инструкций BMI2.


28.12.2016 - Версия 2.1 beta internal (теперь beta public)

- Использование встроенных (intrinsic) функций Microsoft Visual C++
  в качестве опции для 64-разрядного кода на стандартном С.

- Быстрое аппаратное умножение под 64-разрядным Microsoft Visual C++
  без применения дополнительного ассемблерного пакета, ускорение
  примерно в 10 раз.

- Оптимизированное деление 2-3 словного числа на 32/64-разрядный
  делитель с возможностью использования аппаратного деления, если
  установлено макро _CBIGNUM_HARDWARE_DIV.

- Оптимизированный 32/64-разрядный модуль 2-3 словного числа
  с возможностью использования аппаратного деления, если установлено
  макро _CBIGNUM_HARDWARE_DIV.

- Ускоренное в 10 раз возведение в степень по 32/64-разрядному модулю
  при применении транслятора Microsoft Visual C++ 2015 (для других
  трансляторов эффект может быть менее значительным). Возможно
  использование аппаратного деления, если установлено макро
  _CBIGNUM_HARDWARE_DIV.

- Опция _CBIGNUM_REDUCE_JUMPS игнорируется, поскольку оптимизация
  компилятора Microsoft Visual C++ 2015 работает эффективнее.

- Возобновлено бета-тестирование для нового кода.

- ИСПРАВЛЕНО: Опечатка в тесте деления файла Arifrand.


09.06.2017 - Версия 2.1a beta internal

ВЕРСИЯ ПРЕДНАЗНАЧЕНА ТОЛЬКО ДЛЯ ОЗНАКОМЛЕНИЯ И ТЕСТИРОВАНИЯ

- Упрощенный и оптимизированный алгоритм деления неограниченного числа
  на 32/64-разрядный делитель с возможностью использования аппаратного
  деления, если установлено макро _CBIGNUM_HARDWARE_DIV. Этот алгоритм
  заменяет алгоритмы, ранее разработанные для версий 1.2c и 2.1.

- Упрощенный и оптимизированный алгоритм 32/64-разрядного модуля
  неограниченного числа с возможностью использования аппаратного деления,
  если установлено макро _CBIGNUM_HARDWARE_DIV. Заменяет алгоритмы,
  ранее разработанные для версий 1.2c и 2.1. Новый алгоритм ускоряет
  тест "строго вероятной простоты" Миллера в 2 раза для однословных
  чисел и на 20% для двухсловных чисел.

- Обновленный тестовый файл Millrand для больших чисел.


27.06.2017 - Обновление версии 2.1a beta internal (теперь beta public)

ВЕРСИЯ ПРЕДНАЗНАЧЕНА ДЛЯ ОЗНАКОМЛЕНИЯ И ТЕСТИРОВАНИЯ

- Использование встроенных функций компилятора в 32-разрядном Visual C++.

- Макро _CBIGNUM_SMALL_DIV и _CBIGNUM_SMALL_POWMOD для включения тестовых
  алгоритмов для короткого делителя/модуля, реализованных в 2.1 и
  последующих версиях класса.

  ПРИМЕЧАНИЯ: При отключенном макро _CBIGNUM_SMALL_DIV данную тестовую
              версию класса можно использовать для вычислительных целей.

              При отключенных _CBIGNUM_SMALL_DIV и _CBIGNUM_SMALL_POWMOD
              данная версия использует алгоритмы версии 2.0 public.

- ИСПРАВЛЕНО: Неправильный результат деления CBNL_MIN/CNBL_MIN.


27.07.2017 - Версия 2.1b beta internal

ВЕРСИЯ ПРЕДНАЗНАЧЕНА ДЛЯ ОЗНАКОМЛЕНИЯ И ТЕСТИРОВАНИЯ

При использовании версии данной для вычислительных целей следует отключить
макро _CBIGNUM_SMALL_DIV и (возможно) _CBIGNUM_SMALL_POWMOD.

- Оптимизированный алгоритм деления неограниченного числа на
  64/128-разрядный двухсловный делитель, ускорение в 2-3 раза.

- Оптимизированный 64/128-разрядный двухсловный модуль неограниченного
  числа, ускорение в 2-3 раза.

- Ускоренное в 2-3 раза возведение в степень по 64/128-разрядному модулю.

- Использование инструкции LZCNT вместо BSR при трансляции для AVX2
  под Microsoft Visual C++.

- Проверка деления на малый делитель/модуль альтернативным алгоритмом
  с таблицей сдвигов в программе Arifexp.

- ИСПРАВЛЕНО: Методы toCBNL(), tolong(), toint() и toshort()
              не работают для ненормализованных чисел.

- ИСПРАВЛЕНО: Сдвиг на ненормализованное число не работает.

- ИСПРАВЛЕНО: Некорректная отладочная проверка индексов при
              возведении в степень ненормализованного числа.

- ИСПРАВЛЕНО: Ошибка распределения памяти при возведении в
              ненормализованную степень.

- ИСПРАВЛЕНО: Возможно некорректная работа очитка чисел в методах
              clear(), gc() и pack() (ошибка в версии 2.1a бета).


10.09.2017 - Версия 2.1b beta public

ВАЖНОЕ ЗАМЕЧАНИЕ:
При отключенных макро _CBIGNUM_SMALL_DIV и _CBIGNUM_SMALL_POWMOD
данная версия класса использует алгоритмы, протестированные в
версии 2.0 public. Новые алгоритмы деления задействуются только
при включенных макро (по умолчанию). Эти алгоритмы в настоящее
время проходят публичное бета-тестирование и пока не рекомендуются
для проведения достоверных вычислений.

- Оптимизация алгоритмов деления на 32/64/128-разрядный (однословный
  или двухсловный) делитель для сокращения число условных переходов.
  Достигается примерно 2-кратный рост производительности по сравнению
  с исходными реализациями в версиях 2.1a и 2.1b internal.

- Оптимизация 32/64/128-разрядного (однословного или двухсловного)
  модуля неограниченного числа для сокращения число условных переходов.
  Достигается примерно 2-кратный рост производительности по сравнению
  с исходными реализациями в версиях 2.1a и 2.1b, а также на 60-80%
  ускоряется возведение в степень по двухсловному модулю.

- Оптимизация алгоритма степени по однословному модулю для
  сокращения числа условных переходов при трансляции под Microsoft
  Visual C++ 2010 (дает 2-3 кратный рост производительности, ранее
  этот эффект достигался только под Visual C++ 2015).

- Небольшая оптимизация аппаратного деления с модулем, старый
  метод доступен при установленном макро _CBIGNUM_REVERSE_MOD.

- Оптимизация вывода неограниченного числа (около 10% или более
  процентов производительности для относительно небольших чисел).

- Оптимизация методов деления и модуля с таблицей сдвигов для
  снижения накладных расходов.

- ИЗМЕНЕНИЕ: Методы fit(), tab(), smp(), gc() и pack() теперь
             недоступны для константных чисел из-за возможных проблем
             с многопоточностью. Установите макро _CBIGNUM_CONSTCAST
             в файле Cbignum.h, если надо использовать эти методы
             как прежде.

- Новые методы divtab() и modtab(), дополнительная документация
  по методам setdivtab(), setmodtab() и setdivmodtab().

- Из файлов Cbignum.cpp и Cbignumf.inl удален квалификатор
  register с целью соответствия стандарту C++11.

- Проверена совместимость с Microsoft Visual C++ 2017.

- Все программы для Windows теперь компилируются под Microsoft
  Visual C++ 2015 Community ради поддержки встроенных функций
  с переносом/займом. Программы, скомпилированные под Visual C++
  2012 и ниже работают заметно медленнее при операциях с
  двухсловным делителем/модулем.

- Тестовые программы Miller64 и Miller64x для Windows скомпилированы
  с установленным макро _CBIGNUM_HARDWARE_DIV.

- Построены новые исполняемые файлы для Linux с улучшенным кодом
  32/64-разрядного аппаратного умножения и ускоренными операциями
  с малым делителем/модулем.

- ИСПРАВЛЕНО: Prime.cpp не включает аппаратное деление для
              факторизации однословных чисел при компиляции
              в 64-разрядном режиме под Microsoft Visual C++.

- ИСПРАВЛЕНО: Предупреждение компилятора в Prime.cpp, связанное
              с файлом Ctty.h.

- ИСПРАВЛЕНО: Тестовые программы Arifexp64x, Matrix64x и
              Miller64x для процессоров с BMI2 не запускаются
              под 64-разрядной Windows XP.

- ИСПРАВЛЕНО: Завышенная оценка времени деления в программе
              Arifexp для больших делителей размером до
              ~16,000,000 бит.

- ИСПРАВЛЕНО: Генератор случайных чисел может работать неправильно
              при компиляции в более чем 64-разрядном режиме
              (неактуально для современных компиляторов).


10.11.2017 - Обновление документации к версии 2.1b beta pubic

- Исправления в документации и комментариях.


17.11.2017 - Версия 2.1c beta public

ВЕРСИЯ ПРЕДНАЗНАЧЕНА ДЛЯ ОЗНАКОМЛЕНИЯ И ТЕСТИРОВАНИЯ
При использовании в вычислительных целях рекомендуется отключить
макро _CBIGNUM_HARDWARE_MUL для всех трансляторов, кроме
64-разрядного Microsoft Visual C++. См. также важное замечание к
макро _CBIGNUM_SMALL_DIV и _CBIGNUM_SMALL_POWMOD к версии 2.1b.

- Готовится в качестве будущей высокопроизводительной стабильной
  версии на замену 2.0 public.

- Операции над машинными числами перенесены в файл Cbnl.h.

- Использование типа long long для CBNL, если компилятор совместим
  co стандартом С++11.

- Быстрое аппаратное умножение под 32-разрядным Microsoft Visual C++
  без применения дополнительного ассемблерного пакета, ускорение
  примерно в 10 раз.

- Использование аппаратного умножения вместо двоичного метода
  под любым транслятором С++ (двоичный метод доступен при отмене
  макро _CBIGNUM_HARDWARE_MUL).

- Поддержка 64/32 и 128/64-разрядного аппаратного деления в
  дополнительном ассемблерном пакете под Visual C++ и GNU C++.

- Все тестовые 64-битные программы под Windows и Linux компилируются
  с установленным макро _CBIGNUM_HARDWARE_DIV, которое разрешает
  использование аппаратного деления.

- Программы Arifexp и Miller выдают информацию о разрядности и
  методах, применяемых для ускорения вычислений.

- Обновлена оценка времени умножения в программе Arifexp.

- Документирована опция -mhz в программе Arifexp.

- Результаты тестирования производительности для 32-разрядного
  С++ кода с аппаратным умножением.


30.11.2017 - Обновление документации к версии 2.1c beta pubic

- Тест производительности для Core i7-6800K и Phenom II X6.


30.11.2017
